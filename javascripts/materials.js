Jax.environment = Jax.PRODUCTION;


var ApplicationHelper = Jax.Helper.create({

});
var MainHelper = Jax.Helper.create({

});
var NoisyHelper = Jax.Helper.create({
  setupNoise: function(context, mesh, options, uniforms) {
    this.noise = this.noise || new Jax.Noise(context);
    uniforms.texture('permTexture', this.noise.perm, context);
    uniforms.texture('gradTexture', this.noise.grad, context);
    uniforms.texture('simplexTexture', this.noise.simplex, context);
    uniforms.set('TIME', Jax.uptime);
  }
});
var ApplicationController = (function() {
  return Jax.Controller.create("application", Jax.Controller, {

  });
})();

var MainController = (function() {
  var ball;

  return Jax.Controller.create("main", ApplicationController, {
    index: function() {
      this.world.addLightSource(LightSource.find("light"));
      ball = this.world.addObject(new Jax.Model({position:[0,0,-6],mesh:new Jax.Mesh.Sphere({radius:2.0})}));
    },

    update: function(tc) {
      var speed = tc*0.25;
      ball.camera.rotate(speed, [0,1,0]);
      ball.mesh.material = this.material || "sun";
      if (ball.mesh.material == "sun") ball.lit = false;
      else ball.lit = true;
    }
  });
})();
Jax.Material.Electrical = Jax.Class.create(Jax.Material, {
  initialize: function($super, options) {
    options = Jax.Util.normalizeOptions(options, {
      shader: "electrical",

    });

    $super(options);
  },

  setUniforms: function($super, context, mesh, options, uniforms) {
    $super(context, mesh, options, uniforms);

    uniforms.set('mvMatrix', context.getModelViewMatrix());
    uniforms.set('nMatrix', context.getNormalMatrix());
    uniforms.set('pMatrix', context.getProjectionMatrix());

    this.setupNoise(context, mesh, options, uniforms);
  },

  setAttributes: function($super, context, mesh, options, attributes) {
    attributes.set('VERTEX_POSITION',  mesh.getVertexBuffer());
    attributes.set('VERTEX_COLOR',     mesh.getColorBuffer());
    attributes.set('VERTEX_NORMAL',    mesh.getNormalBuffer());
    attributes.set('VERTEX_TEXCOORDS', mesh.getTextureCoordsBuffer());
  },

  helpers: function() { return [NoisyHelper]; }
});
Jax.Material.Granite = Jax.Class.create(Jax.Material, {
  initialize: function($super, options) {
    options = Jax.Util.normalizeOptions(options, {
      shader: "granite",

    });

    $super(options);
  },

  setUniforms: function($super, context, mesh, options, uniforms) {
    $super(context, mesh, options, uniforms);

    uniforms.set('mvMatrix', context.getModelViewMatrix());
    uniforms.set('nMatrix', context.getNormalMatrix());
    uniforms.set('pMatrix', context.getProjectionMatrix());

    this.setupNoise(context, mesh, options, uniforms);
  },

  helpers: function() { return [NoisyHelper]; },

  setAttributes: function($super, context, mesh, options, attributes) {
    attributes.set('VERTEX_POSITION',  mesh.getVertexBuffer());
    attributes.set('VERTEX_COLOR',     mesh.getColorBuffer());
    attributes.set('VERTEX_NORMAL',    mesh.getNormalBuffer());
    attributes.set('VERTEX_TEXCOORDS', mesh.getTextureCoordsBuffer());
  }
});
Jax.Material.Sun = Jax.Class.create(Jax.Material, {
  initialize: function($super, options) {
    options = Jax.Util.normalizeOptions(options, {
      shader: "sun",

    });

    $super(options);
  },

  setUniforms: function($super, context, mesh, options, uniforms) {
    $super(context, mesh, options, uniforms);

    uniforms.set('mvMatrix', context.getModelViewMatrix());
    uniforms.set('nMatrix', context.getNormalMatrix());
    uniforms.set('pMatrix', context.getProjectionMatrix());

    this.setupNoise(context, mesh, options, uniforms);
  },

  setAttributes: function($super, context, mesh, options, attributes) {
    attributes.set('VERTEX_POSITION',  mesh.getVertexBuffer());
    attributes.set('VERTEX_COLOR',     mesh.getColorBuffer());
    attributes.set('VERTEX_NORMAL',    mesh.getNormalBuffer());
    attributes.set('VERTEX_TEXCOORDS', mesh.getTextureCoordsBuffer());
  },

  helpers: function() { return [NoisyHelper]; }
});
Jax.Material.Wood = Jax.Class.create(Jax.Material, {
  initialize: function($super, options) {
    options = Jax.Util.normalizeOptions(options, {
      shader: "wood",

    });

    $super(options);
  },

  setUniforms: function($super, context, mesh, options, uniforms) {
    $super(context, mesh, options, uniforms);

    uniforms.set('mvMatrix', context.getModelViewMatrix());
    uniforms.set('nMatrix', context.getNormalMatrix());
    uniforms.set('pMatrix', context.getProjectionMatrix());

    this.setupNoise(context, mesh, options, uniforms);
  },

  setAttributes: function($super, context, mesh, options, attributes) {
    attributes.set('VERTEX_POSITION',  mesh.getVertexBuffer());
    attributes.set('VERTEX_COLOR',     mesh.getColorBuffer());
    attributes.set('VERTEX_NORMAL',    mesh.getNormalBuffer());
    attributes.set('VERTEX_TEXCOORDS', mesh.getTextureCoordsBuffer());
  },

  helpers: function() { return [NoisyHelper]; }
});
Jax.views.push('main/index', function() {
  this.glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  this.world.render();
});
Jax.shaders['basic'] = new Jax.Shader({  common:"shared uniform mat4 ivMatrix, mvMatrix, pMatrix, vMatrix;\nshared uniform mat3 vnMatrix, nMatrix;\n\nshared uniform vec4 materialDiffuse, materialAmbient, materialSpecular;\nshared uniform float materialShininess;\n\nshared uniform int PASS_TYPE;\n\nshared varying vec2 vTexCoords;\nshared varying vec3 vNormal, vSurfacePos;\nshared varying vec4 vBaseColor;\n",
  fragment:"void main(inout vec4 ambient, inout vec4 diffuse, inout vec4 specular) {\n  ambient = materialAmbient * vBaseColor;\n  diffuse = materialDiffuse * vBaseColor;\n  specular = materialSpecular * vBaseColor;\n}\n",
  vertex:"shared attribute vec2 VERTEX_TEXCOORDS;\nshared attribute vec3 VERTEX_NORMAL;\nshared attribute vec4 VERTEX_POSITION, VERTEX_COLOR, VERTEX_TANGENT;\n\nvoid main(void) {\n  vBaseColor = VERTEX_COLOR;\n  vNormal = nMatrix * VERTEX_NORMAL;\n  vTexCoords = VERTEX_TEXCOORDS;\n                          \n  vSurfacePos = (mvMatrix * VERTEX_POSITION).xyz;\n\n  gl_Position = pMatrix * mvMatrix * VERTEX_POSITION;\n}\n",
exports: {},
name: "basic"});
Jax.shaders['depthmap'] = new Jax.Shader({  common:"shared uniform mat4 pMatrix;\n",
  fragment:"          #ifndef dependency_functions_depth_map\n          #define dependency_functions_depth_map\n      \n          vec4 pack_depth(const in float depth)\n{\n  const vec4 bit_shift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\n  const vec4 bit_mask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\n  vec4 res = fract(depth * bit_shift);\n  res -= res.xxyz * bit_mask;\n  return res;\n}\n\n/*\nfloat linearize(in float z) {\n  float A = pMatrix[2].z, B = pMatrix[3].z;\n  float n = - B / (1.0 - A); // camera z near\n  float f =   B / (1.0 + A); // camera z far\n  return (2.0 * n) / (f + n - z * (f - n));\n}\n*/\n\nfloat unpack_depth(const in vec4 rgba_depth)\n{\n  const vec4 bit_shift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\n  float depth = dot(rgba_depth, bit_shift);\n  return depth;\n}\n\n          #endif\n\n\nvoid main(void) {\n  vec4 pos = gl_FragCoord;\n  import(exPos, pos = exPos);\n  gl_FragColor = pack_depth(pos.z);\n}\n",
  vertex:"shared attribute vec4 VERTEX_POSITION;\n    \nshared uniform mat4 mvMatrix;\n            \nvoid main(void) {\n  vec4 pos = pMatrix * mvMatrix * VERTEX_POSITION;\n  import(Position, pos = Position);\n  \n  gl_Position = pos;\n}\n",
exports: {},
name: "depthmap"});
Jax.shaders['fog'] = new Jax.Shader({  common:"uniform vec4 FogColor;\n\nuniform int Algorithm;\n\nuniform float Scale;\nuniform float End;\nuniform float Density;\n",
  fragment:"const float LOG2 = 1.442695;\n\nvoid main(inout vec4 ambient, inout vec4 diffuse, inout vec4 specular) {\n  float fog;\n  float distance = length(gl_FragCoord.z / gl_FragCoord.w);\n\n  if (Algorithm == <%=Jax.LINEAR%>) {\n    fog = (End - distance) * Scale;\n  } else if (Algorithm == <%=Jax.EXPONENTIAL%>) {\n    fog = exp(-Density * distance);\n  } else if (Algorithm == <%=Jax.EXP2%>) {\n    fog = exp2(-Density * Density * distance * distance * LOG2);\n  } else {\n    /* error condition, output red */\n    ambient = diffuse = specular = vec4(1,0,0,1);\n    return;\n  }\n\n  fog = clamp(fog, 0.0, 1.0);\n  \n  ambient  = mix(FogColor,  ambient,  fog);\n  diffuse  = mix(FogColor,  diffuse,  fog);\n}\n",
  vertex:"shared attribute vec4 VERTEX_POSITION;\n\nshared uniform mat4 mvMatrix, pMatrix;\n\nconst float LOG2 = 1.442695;\n\nvoid main(void) {\n  vec4 pos = mvMatrix * VERTEX_POSITION;\n  gl_Position = pMatrix * pos;\n}\n",
exports: {},
name: "fog"});
Jax.shaders['lighting'] = new Jax.Shader({  common:"          #ifndef dependency_functions_lights\n          #define dependency_functions_lights\n      \n          /* see http://jax.thoughtsincomputation.com/2011/05/webgl-apps-crashing-on-windows-7/ */\n//const struct LightSource {\n//  int enabled;\n//  int type;\n//  vec3 position; // in world space\n//  vec3 direction; // in world space\n//  vec4 ambient, diffuse, specular;\n//  float constant_attenuation, linear_attenuation, quadratic_attenuation;\n//  float spotExponent, spotCosCutoff;\n//};\n\nshared uniform bool LIGHT_ENABLED;\nshared uniform int LIGHT_TYPE;\nshared uniform vec3 LIGHT_POSITION, LIGHT_DIRECTION;\nshared uniform vec4 LIGHT_AMBIENT, LIGHT_DIFFUSE, LIGHT_SPECULAR;\nshared uniform float LIGHT_ATTENUATION_CONSTANT, LIGHT_ATTENUATION_LINEAR, LIGHT_ATTENUATION_QUADRATIC,\n                     LIGHT_SPOT_EXPONENT, LIGHT_SPOT_COS_CUTOFF;\n\nfloat calcAttenuation(in vec3 ecPosition3,\n                      out vec3 lightDirection)\n{\n//  lightDirection = vec3(vnMatrix * -light.position) - ecPosition3;\n  lightDirection = vec3(ivMatrix * vec4(LIGHT_POSITION, 1.0)) - ecPosition3;\n  float d = length(lightDirection);\n  \n  return 1.0 / (LIGHT_ATTENUATION_CONSTANT + LIGHT_ATTENUATION_LINEAR * d + LIGHT_ATTENUATION_QUADRATIC * d * d);\n}\n\nvoid DirectionalLight(in vec3 normal,\n                      inout vec4 ambient,\n                      inout vec4 diffuse,\n                      inout vec4 specular)\n{\n  vec3 nLDir = normalize(vnMatrix * -normalize(LIGHT_DIRECTION));\n  vec3 halfVector = normalize(nLDir + vec3(0,0,1));\n  float pf;\n    \n  float NdotD  = max(0.0, dot(normal, nLDir));\n  float NdotHV = max(0.0, dot(normal, halfVector));\n    \n  if (NdotD == 0.0) pf = 0.0;\n  else pf = pow(NdotHV, materialShininess);\n    \n  ambient += LIGHT_AMBIENT;\n  diffuse += LIGHT_DIFFUSE * NdotD;\n  specular += LIGHT_SPECULAR * pf;\n}\n\n/* Use when attenuation != (1,0,0) */\nvoid PointLightWithAttenuation(in vec3 ecPosition3,\n                               in vec3 normal,\n                               inout vec4 ambient,\n                               inout vec4 diffuse,\n                               inout vec4 specular)\n{\n  float NdotD; // normal . light direction\n  float NdotHV;// normal . half vector\n  float pf;    // specular factor\n  float attenuation;\n  vec3 VP;     // direction from surface to light position\n  vec3 halfVector; // direction of maximum highlights\n  \n  attenuation = calcAttenuation(ecPosition3, VP);\n  VP = normalize(VP);\n  \n  halfVector = normalize(VP+vec3(0,0,1));\n  NdotD = max(0.0, dot(normal, VP));\n  NdotHV= max(0.0, dot(normal, halfVector));\n  \n  if (NdotD == 0.0) pf = 0.0;\n  else pf = pow(NdotHV, materialShininess);\n\n  ambient += LIGHT_AMBIENT * attenuation;\n  diffuse += LIGHT_DIFFUSE * NdotD * attenuation;\n  specular += LIGHT_SPECULAR * pf * attenuation;\n}\n\n/* Use for better performance when attenuation == (1,0,0) */\nvoid PointLightWithoutAttenuation(in vec3 ecPosition3,\n                                  in vec3 normal,\n                                  inout vec4 ambient,\n                                  inout vec4 diffuse,\n                                  inout vec4 specular)\n{\n  float NdotD; // normal . light direction\n  float NdotHV;// normal . half vector\n  float pf;    // specular factor\n  float d;     // distance from surface to light source\n  vec3 VP;     // direction from surface to light position\n  vec3 halfVector; // direction of maximum highlights\n  \n  VP = vec3(ivMatrix * vec4(LIGHT_POSITION, 1.0)) - ecPosition3;\n  d = length(VP);\n  VP = normalize(VP);\n  halfVector = normalize(VP+vec3(0,0,1));\n  NdotD = max(0.0, dot(normal, VP));\n  NdotHV= max(0.0, dot(normal, halfVector));\n  \n  if (NdotD == 0.0) pf = 0.0;\n  else pf = pow(NdotHV, materialShininess);\n  \n  ambient += LIGHT_AMBIENT;\n  diffuse += LIGHT_DIFFUSE * NdotD;\n  specular += LIGHT_SPECULAR * pf;\n}\n\nvoid SpotLight(in vec3 ecPosition3,\n               in vec3 normal,\n               inout vec4 ambient,\n               inout vec4 diffuse,\n               inout vec4 specular)\n{\n  float NdotD; // normal . light direction\n  float NdotHV;// normal . half vector\n  float pf;    // specular factor\n  float attenuation;\n  vec3 VP;     // direction from surface to light position\n  vec3 halfVector; // direction of maximum highlights\n  float spotDot; // cosine of angle between spotlight\n  float spotAttenuation; // spotlight attenuation factor\n  \n  attenuation = calcAttenuation(ecPosition3, VP);\n  VP = normalize(VP);\n  \n  // See if point on surface is inside cone of illumination\n  spotDot = dot(-VP, normalize(vnMatrix*LIGHT_DIRECTION));\n  if (spotDot < LIGHT_SPOT_COS_CUTOFF)\n    spotAttenuation = 0.0;\n  else spotAttenuation = pow(spotDot, LIGHT_SPOT_EXPONENT);\n  \n  attenuation *= spotAttenuation;\n  \n  halfVector = normalize(VP+vec3(0,0,1));\n  NdotD = max(0.0, dot(normal, VP));\n  NdotHV= max(0.0, dot(normal, halfVector));\n  \n  if (NdotD == 0.0) pf = 0.0;\n  else pf = pow(NdotHV, materialShininess);\n  \n  ambient += LIGHT_AMBIENT * attenuation;\n  diffuse += LIGHT_DIFFUSE * NdotD * attenuation;\n  specular += LIGHT_SPECULAR * pf * attenuation;\n}\n\n          #endif\n\n\nshared uniform bool LIGHTING_ENABLED;\n\nshared varying vec3 vLightDir;",
  fragment:"void main(inout vec4 ambient, inout vec4 diffuse, inout vec4 specular) {\n  vec4 _ambient = vec4(0), _diffuse = vec4(0), _specular = vec4(0);\n  \n  vec3 nNormal = normalize(vNormal);\n\n  if (LIGHTING_ENABLED) {\n    if (LIGHT_TYPE == <%=Jax.DIRECTIONAL_LIGHT%>)\n      DirectionalLight(nNormal, _ambient, _diffuse, _specular);\n    else\n      if (LIGHT_TYPE == <%=Jax.POINT_LIGHT%>)\n        if (LIGHT_ATTENUATION_CONSTANT == 1.0 && LIGHT_ATTENUATION_LINEAR == 0.0 && LIGHT_ATTENUATION_QUADRATIC == 0.0)\n          PointLightWithoutAttenuation(vSurfacePos, nNormal, _ambient, _diffuse, _specular);\n        else\n          PointLightWithAttenuation(vSurfacePos, nNormal, _ambient, _diffuse, _specular);\n      else\n        if (LIGHT_TYPE == <%=Jax.SPOT_LIGHT%>)\n          SpotLight(vSurfacePos, nNormal, _ambient, _diffuse, _specular);\n        else\n        { // error condition, output 100% red\n          gl_FragColor = vec4(1,0,0,1);\n          return;\n        }\n  } else {\n    _ambient = vec4(1,1,1,1);\n    _diffuse = _specular = vec4(0,0,0,0);\n  }\n\n  /*\n    Light colors will be multiplied by material colors. Light can't really be transparent,\n    so we'll use alpha to represent intensity. This means we must multiply resultant light\n    colors by light alpha, and then hard-code alpha 1 to avoid polluting transparency.\n    \n    The reason we use LIGHT_*.a instead of _*.a is because _*.a has been tainted by attenuation.\n    A light's intensity, regardless of distance or relative brightness, has not actually changed;\n    attenuation has been factored into color already; we don't want to square the atten amt.\n  */\n  ambient *= vec4(_ambient.rgb * LIGHT_AMBIENT.a, 1.0);\n  diffuse *= vec4(_diffuse.rgb * LIGHT_DIFFUSE.a, 1.0);\n  specular *= vec4(_specular.rgb * LIGHT_SPECULAR.a, 1.0);\n}\n",
  vertex:"shared attribute vec2 VERTEX_TEXCOORDS;\nshared attribute vec3 VERTEX_NORMAL;\nshared attribute vec4 VERTEX_POSITION, VERTEX_COLOR, VERTEX_TANGENT;\n\nvoid main(void) {\n  vLightDir = normalize(vnMatrix * -normalize(LIGHT_DIRECTION));\n}\n",
exports: {},
name: "lighting"});
Jax.shaders['normal_map'] = new Jax.Shader({  common:"          #ifndef dependency_functions_lights\n          #define dependency_functions_lights\n      \n          /* see http://jax.thoughtsincomputation.com/2011/05/webgl-apps-crashing-on-windows-7/ */\n//const struct LightSource {\n//  int enabled;\n//  int type;\n//  vec3 position; // in world space\n//  vec3 direction; // in world space\n//  vec4 ambient, diffuse, specular;\n//  float constant_attenuation, linear_attenuation, quadratic_attenuation;\n//  float spotExponent, spotCosCutoff;\n//};\n\nshared uniform bool LIGHT_ENABLED;\nshared uniform int LIGHT_TYPE;\nshared uniform vec3 LIGHT_POSITION, LIGHT_DIRECTION;\nshared uniform vec4 LIGHT_AMBIENT, LIGHT_DIFFUSE, LIGHT_SPECULAR;\nshared uniform float LIGHT_ATTENUATION_CONSTANT, LIGHT_ATTENUATION_LINEAR, LIGHT_ATTENUATION_QUADRATIC,\n                     LIGHT_SPOT_EXPONENT, LIGHT_SPOT_COS_CUTOFF;\n\nfloat calcAttenuation(in vec3 ecPosition3,\n                      out vec3 lightDirection)\n{\n//  lightDirection = vec3(vnMatrix * -light.position) - ecPosition3;\n  lightDirection = vec3(ivMatrix * vec4(LIGHT_POSITION, 1.0)) - ecPosition3;\n  float d = length(lightDirection);\n  \n  return 1.0 / (LIGHT_ATTENUATION_CONSTANT + LIGHT_ATTENUATION_LINEAR * d + LIGHT_ATTENUATION_QUADRATIC * d * d);\n}\n\nvoid DirectionalLight(in vec3 normal,\n                      inout vec4 ambient,\n                      inout vec4 diffuse,\n                      inout vec4 specular)\n{\n  vec3 nLDir = normalize(vnMatrix * -normalize(LIGHT_DIRECTION));\n  vec3 halfVector = normalize(nLDir + vec3(0,0,1));\n  float pf;\n    \n  float NdotD  = max(0.0, dot(normal, nLDir));\n  float NdotHV = max(0.0, dot(normal, halfVector));\n    \n  if (NdotD == 0.0) pf = 0.0;\n  else pf = pow(NdotHV, materialShininess);\n    \n  ambient += LIGHT_AMBIENT;\n  diffuse += LIGHT_DIFFUSE * NdotD;\n  specular += LIGHT_SPECULAR * pf;\n}\n\n/* Use when attenuation != (1,0,0) */\nvoid PointLightWithAttenuation(in vec3 ecPosition3,\n                               in vec3 normal,\n                               inout vec4 ambient,\n                               inout vec4 diffuse,\n                               inout vec4 specular)\n{\n  float NdotD; // normal . light direction\n  float NdotHV;// normal . half vector\n  float pf;    // specular factor\n  float attenuation;\n  vec3 VP;     // direction from surface to light position\n  vec3 halfVector; // direction of maximum highlights\n  \n  attenuation = calcAttenuation(ecPosition3, VP);\n  VP = normalize(VP);\n  \n  halfVector = normalize(VP+vec3(0,0,1));\n  NdotD = max(0.0, dot(normal, VP));\n  NdotHV= max(0.0, dot(normal, halfVector));\n  \n  if (NdotD == 0.0) pf = 0.0;\n  else pf = pow(NdotHV, materialShininess);\n\n  ambient += LIGHT_AMBIENT * attenuation;\n  diffuse += LIGHT_DIFFUSE * NdotD * attenuation;\n  specular += LIGHT_SPECULAR * pf * attenuation;\n}\n\n/* Use for better performance when attenuation == (1,0,0) */\nvoid PointLightWithoutAttenuation(in vec3 ecPosition3,\n                                  in vec3 normal,\n                                  inout vec4 ambient,\n                                  inout vec4 diffuse,\n                                  inout vec4 specular)\n{\n  float NdotD; // normal . light direction\n  float NdotHV;// normal . half vector\n  float pf;    // specular factor\n  float d;     // distance from surface to light source\n  vec3 VP;     // direction from surface to light position\n  vec3 halfVector; // direction of maximum highlights\n  \n  VP = vec3(ivMatrix * vec4(LIGHT_POSITION, 1.0)) - ecPosition3;\n  d = length(VP);\n  VP = normalize(VP);\n  halfVector = normalize(VP+vec3(0,0,1));\n  NdotD = max(0.0, dot(normal, VP));\n  NdotHV= max(0.0, dot(normal, halfVector));\n  \n  if (NdotD == 0.0) pf = 0.0;\n  else pf = pow(NdotHV, materialShininess);\n  \n  ambient += LIGHT_AMBIENT;\n  diffuse += LIGHT_DIFFUSE * NdotD;\n  specular += LIGHT_SPECULAR * pf;\n}\n\nvoid SpotLight(in vec3 ecPosition3,\n               in vec3 normal,\n               inout vec4 ambient,\n               inout vec4 diffuse,\n               inout vec4 specular)\n{\n  float NdotD; // normal . light direction\n  float NdotHV;// normal . half vector\n  float pf;    // specular factor\n  float attenuation;\n  vec3 VP;     // direction from surface to light position\n  vec3 halfVector; // direction of maximum highlights\n  float spotDot; // cosine of angle between spotlight\n  float spotAttenuation; // spotlight attenuation factor\n  \n  attenuation = calcAttenuation(ecPosition3, VP);\n  VP = normalize(VP);\n  \n  // See if point on surface is inside cone of illumination\n  spotDot = dot(-VP, normalize(vnMatrix*LIGHT_DIRECTION));\n  if (spotDot < LIGHT_SPOT_COS_CUTOFF)\n    spotAttenuation = 0.0;\n  else spotAttenuation = pow(spotDot, LIGHT_SPOT_EXPONENT);\n  \n  attenuation *= spotAttenuation;\n  \n  halfVector = normalize(VP+vec3(0,0,1));\n  NdotD = max(0.0, dot(normal, VP));\n  NdotHV= max(0.0, dot(normal, halfVector));\n  \n  if (NdotD == 0.0) pf = 0.0;\n  else pf = pow(NdotHV, materialShininess);\n  \n  ambient += LIGHT_AMBIENT * attenuation;\n  diffuse += LIGHT_DIFFUSE * NdotD * attenuation;\n  specular += LIGHT_SPECULAR * pf * attenuation;\n}\n\n          #endif\n\n\nuniform sampler2D NormalMap;\n\nshared uniform mat4 mvMatrix, pMatrix, vMatrix;\nshared uniform mat3 nMatrix;\n\nshared varying vec2 vTexCoords;\n\nvarying vec3 vEyeDir;\nvarying vec3 vLightDir;\nvarying float vAttenuation;\n",
  fragment:"void main(inout vec4 ambient, inout vec4 diffuse, inout vec4 specular) {\n  // ambient was applied by the basic shader; applying it again will simply brighten some fragments\n  // beyond their proper ambient value. So, we really need to apply the bump shader ONLY to diffuse+specular.\n\n  if (PASS_TYPE == <%=Jax.Scene.AMBIENT_PASS%>) return;\n  \n  vec3 nLightDir = normalize(vLightDir);\n  vec3 nEyeDir = normalize(vEyeDir);\n  vec4 color = texture2D(NormalMap, vTexCoords);\n  vec3 map = //nMatrix * \n             normalize(color.xyz * 2.0 - 1.0);\n             \n  float litColor = max(dot(map, nLightDir), 0.0) * vAttenuation;\n\n  // specular\n  vec3 reflectDir = reflect(nLightDir, map);\n  float spec = max(dot(nEyeDir, reflectDir), 0.0);\n  spec = pow(spec, materialShininess);\n\n  // Treat alpha in the normal map as a specular map; if it's unused it will be 1 and this\n  // won't matter.\n  spec *= color.a;\n  \n  diffuse *= litColor;\n  specular *= spec;\n}\n",
  vertex:"shared attribute vec4 VERTEX_POSITION;\nshared attribute vec2 VERTEX_TEXCOORDS;\nshared attribute vec4 VERTEX_TANGENT;\nshared attribute vec3 VERTEX_NORMAL;\n\nvoid main(void) {\n  // ambient was applied by the basic shader; applying it again will simply brighten some fragments\n  // beyond their proper ambient value. So, we really need to apply the bump shader ONLY to diffuse+specular.\n\n  if (PASS_TYPE == <%=Jax.Scene.AMBIENT_PASS%>) return;\n\n  vec3 ecPosition = vec3(mvMatrix * VERTEX_POSITION);\n\n  gl_Position = pMatrix * mvMatrix * VERTEX_POSITION;\n  vTexCoords = VERTEX_TEXCOORDS;\n\n  vEyeDir = vec3(mvMatrix * VERTEX_POSITION);\n  \n  vec3 n = normalize(nMatrix * VERTEX_NORMAL);\n  vec3 t = normalize(nMatrix * VERTEX_TANGENT.xyz);\n  vec3 b = cross(n, t) * VERTEX_TANGENT.w;\n  \n  vec3 v, p;\n  \n  vAttenuation = 1.0;\n  \n  if (LIGHT_TYPE == <%=Jax.POINT_LIGHT%>)\n    if (LIGHT_ATTENUATION_CONSTANT == 1.0 && LIGHT_ATTENUATION_LINEAR == 0.0 && LIGHT_ATTENUATION_QUADRATIC == 0.0) {\n      // no change to attenuation, but we still need P\n      p = vec3(ivMatrix * vec4(LIGHT_POSITION, 1.0)) - ecPosition;\n    }\n    else {\n      // attenuation calculation figures out P for us, so we may as well use it\n      vAttenuation = calcAttenuation(ecPosition, p);\n    }\n  else\n    if (LIGHT_TYPE == <%=Jax.SPOT_LIGHT%>) {\n      // attenuation calculation figures out P for us, so we may as well use it\n      vAttenuation = calcAttenuation(ecPosition, p);\n    }\n    else\n    { // directional light -- all we need is P\n      p = vec3(vnMatrix * -normalize(LIGHT_DIRECTION));\n    }\n    \n    \n    \n  v.x = dot(p, t);\n  v.y = dot(p, b);\n  v.z = dot(p, n);\n  vLightDir = normalize(p);\n  \n  v.x = dot(vEyeDir, t);\n  v.y = dot(vEyeDir, b);\n  v.z = dot(vEyeDir, n);\n  vEyeDir = normalize(v);\n}\n",
exports: {},
name: "normal_map"});
Jax.shaders['paraboloid'] = new Jax.Shader({  common:"shared uniform mat4 mvMatrix;\nshared uniform float DP_SHADOW_NEAR, DP_SHADOW_FAR;\nshared uniform float DP_DIRECTION;\n\nvarying float vClip;\nvarying vec4 vPos;\n",
  fragment:"void main(void) {\n  /* because we do our own projection, we also have to do our own clipping */\n  /* if vClip is less than 0, it's behind the near plane and can be dropped. */\n  if (vClip < 0.0) discard;\n  \n  export(vec4, exPos, vPos);\n//  gl_FragColor = pack_depth(vPos.z);\n}\n",
  vertex:"shared attribute vec4 VERTEX_POSITION;\n                \nvoid main(void) {\n  /*\n    we do our own projection to form the paraboloid, so we\n    can ignore the projection matrix entirely.\n   */\n  vec4 pos = mvMatrix * VERTEX_POSITION;\n\n  pos = vec4(pos.xyz / pos.w, pos.w);\n\n  pos.z *= DP_DIRECTION;\n\n  float L = length(pos.xyz);\n  pos /= L;\n  vClip = pos.z;\n\n  pos.z += 1.0;\n  pos.x /= pos.z;\n  pos.y /= pos.z;\n  pos.z = (L - DP_SHADOW_NEAR) / (DP_SHADOW_FAR - DP_SHADOW_NEAR);\n  pos.w = 1.0;\n\n  vPos = pos;\n  export(vec4, Position, pos);\n  gl_Position = pos;\n}\n",
exports: {"exPos":"vec4","Position":"vec4"},
name: "paraboloid"});
Jax.shaders['picking'] = new Jax.Shader({  common:"uniform float INDEX;\nvarying vec4 vColor;\n",
  fragment:"void main(void) {\n  if (INDEX == -1.0) discard;\n  gl_FragColor = vColor;\n}\n",
  vertex:"shared attribute vec4 VERTEX_POSITION;\n\nshared uniform mat4 mvMatrix, pMatrix;\n\nvoid main(void) {\n  gl_Position = pMatrix * mvMatrix * VERTEX_POSITION;\n  \n  /*\n    Note that the agorithm here must be followed exactly on the JS side in order\n    to reconstitute the index when it is read.\n    \n    This supports 65,535 objects. If more are needed, we could feasibly open up\n    the alpha channel, as long as blending is disabled. Need to do more tests\n    on this first, however.\n  */\n  \n  \n  // equivalent to [ int(INDEX/256), INDEX % 256 ] / 255. The last division\n  // is necessary to scale to the [0..1] range.\n  \n  float d = 1.0 / 255.0;\n  float f = floor(INDEX / 256.0);\n  vColor = vec4(f * d, (INDEX - 256.0 * f) * d, 1.0, 1.0);\n}\n",
exports: {},
name: "picking"});
Jax.shaders['shadow_map'] = new Jax.Shader({  common:"shared uniform mat4 mMatrix;\n\nuniform bool SHADOWMAP_ENABLED;\nuniform sampler2D SHADOWMAP0, SHADOWMAP1;\nuniform mat4 SHADOWMAP_MATRIX;\nuniform bool SHADOWMAP_PCF_ENABLED;\nuniform float DP_SHADOW_NEAR, DP_SHADOW_FAR;\n\nvarying vec4 vShadowCoord;\n\nvarying vec4 vDP0, vDP1;\n//varying float vDPz, vDPDepth;\n\n          #ifndef dependency_functions_lights\n          #define dependency_functions_lights\n      \n          /* see http://jax.thoughtsincomputation.com/2011/05/webgl-apps-crashing-on-windows-7/ */\n//const struct LightSource {\n//  int enabled;\n//  int type;\n//  vec3 position; // in world space\n//  vec3 direction; // in world space\n//  vec4 ambient, diffuse, specular;\n//  float constant_attenuation, linear_attenuation, quadratic_attenuation;\n//  float spotExponent, spotCosCutoff;\n//};\n\nshared uniform bool LIGHT_ENABLED;\nshared uniform int LIGHT_TYPE;\nshared uniform vec3 LIGHT_POSITION, LIGHT_DIRECTION;\nshared uniform vec4 LIGHT_AMBIENT, LIGHT_DIFFUSE, LIGHT_SPECULAR;\nshared uniform float LIGHT_ATTENUATION_CONSTANT, LIGHT_ATTENUATION_LINEAR, LIGHT_ATTENUATION_QUADRATIC,\n                     LIGHT_SPOT_EXPONENT, LIGHT_SPOT_COS_CUTOFF;\n\nfloat calcAttenuation(in vec3 ecPosition3,\n                      out vec3 lightDirection)\n{\n//  lightDirection = vec3(vnMatrix * -light.position) - ecPosition3;\n  lightDirection = vec3(ivMatrix * vec4(LIGHT_POSITION, 1.0)) - ecPosition3;\n  float d = length(lightDirection);\n  \n  return 1.0 / (LIGHT_ATTENUATION_CONSTANT + LIGHT_ATTENUATION_LINEAR * d + LIGHT_ATTENUATION_QUADRATIC * d * d);\n}\n\nvoid DirectionalLight(in vec3 normal,\n                      inout vec4 ambient,\n                      inout vec4 diffuse,\n                      inout vec4 specular)\n{\n  vec3 nLDir = normalize(vnMatrix * -normalize(LIGHT_DIRECTION));\n  vec3 halfVector = normalize(nLDir + vec3(0,0,1));\n  float pf;\n    \n  float NdotD  = max(0.0, dot(normal, nLDir));\n  float NdotHV = max(0.0, dot(normal, halfVector));\n    \n  if (NdotD == 0.0) pf = 0.0;\n  else pf = pow(NdotHV, materialShininess);\n    \n  ambient += LIGHT_AMBIENT;\n  diffuse += LIGHT_DIFFUSE * NdotD;\n  specular += LIGHT_SPECULAR * pf;\n}\n\n/* Use when attenuation != (1,0,0) */\nvoid PointLightWithAttenuation(in vec3 ecPosition3,\n                               in vec3 normal,\n                               inout vec4 ambient,\n                               inout vec4 diffuse,\n                               inout vec4 specular)\n{\n  float NdotD; // normal . light direction\n  float NdotHV;// normal . half vector\n  float pf;    // specular factor\n  float attenuation;\n  vec3 VP;     // direction from surface to light position\n  vec3 halfVector; // direction of maximum highlights\n  \n  attenuation = calcAttenuation(ecPosition3, VP);\n  VP = normalize(VP);\n  \n  halfVector = normalize(VP+vec3(0,0,1));\n  NdotD = max(0.0, dot(normal, VP));\n  NdotHV= max(0.0, dot(normal, halfVector));\n  \n  if (NdotD == 0.0) pf = 0.0;\n  else pf = pow(NdotHV, materialShininess);\n\n  ambient += LIGHT_AMBIENT * attenuation;\n  diffuse += LIGHT_DIFFUSE * NdotD * attenuation;\n  specular += LIGHT_SPECULAR * pf * attenuation;\n}\n\n/* Use for better performance when attenuation == (1,0,0) */\nvoid PointLightWithoutAttenuation(in vec3 ecPosition3,\n                                  in vec3 normal,\n                                  inout vec4 ambient,\n                                  inout vec4 diffuse,\n                                  inout vec4 specular)\n{\n  float NdotD; // normal . light direction\n  float NdotHV;// normal . half vector\n  float pf;    // specular factor\n  float d;     // distance from surface to light source\n  vec3 VP;     // direction from surface to light position\n  vec3 halfVector; // direction of maximum highlights\n  \n  VP = vec3(ivMatrix * vec4(LIGHT_POSITION, 1.0)) - ecPosition3;\n  d = length(VP);\n  VP = normalize(VP);\n  halfVector = normalize(VP+vec3(0,0,1));\n  NdotD = max(0.0, dot(normal, VP));\n  NdotHV= max(0.0, dot(normal, halfVector));\n  \n  if (NdotD == 0.0) pf = 0.0;\n  else pf = pow(NdotHV, materialShininess);\n  \n  ambient += LIGHT_AMBIENT;\n  diffuse += LIGHT_DIFFUSE * NdotD;\n  specular += LIGHT_SPECULAR * pf;\n}\n\nvoid SpotLight(in vec3 ecPosition3,\n               in vec3 normal,\n               inout vec4 ambient,\n               inout vec4 diffuse,\n               inout vec4 specular)\n{\n  float NdotD; // normal . light direction\n  float NdotHV;// normal . half vector\n  float pf;    // specular factor\n  float attenuation;\n  vec3 VP;     // direction from surface to light position\n  vec3 halfVector; // direction of maximum highlights\n  float spotDot; // cosine of angle between spotlight\n  float spotAttenuation; // spotlight attenuation factor\n  \n  attenuation = calcAttenuation(ecPosition3, VP);\n  VP = normalize(VP);\n  \n  // See if point on surface is inside cone of illumination\n  spotDot = dot(-VP, normalize(vnMatrix*LIGHT_DIRECTION));\n  if (spotDot < LIGHT_SPOT_COS_CUTOFF)\n    spotAttenuation = 0.0;\n  else spotAttenuation = pow(spotDot, LIGHT_SPOT_EXPONENT);\n  \n  attenuation *= spotAttenuation;\n  \n  halfVector = normalize(VP+vec3(0,0,1));\n  NdotD = max(0.0, dot(normal, VP));\n  NdotHV= max(0.0, dot(normal, halfVector));\n  \n  if (NdotD == 0.0) pf = 0.0;\n  else pf = pow(NdotHV, materialShininess);\n  \n  ambient += LIGHT_AMBIENT * attenuation;\n  diffuse += LIGHT_DIFFUSE * NdotD * attenuation;\n  specular += LIGHT_SPECULAR * pf * attenuation;\n}\n\n          #endif\n\n",
  fragment:"          #ifndef dependency_functions_depth_map\n          #define dependency_functions_depth_map\n      \n          vec4 pack_depth(const in float depth)\n{\n  const vec4 bit_shift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\n  const vec4 bit_mask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\n  vec4 res = fract(depth * bit_shift);\n  res -= res.xxyz * bit_mask;\n  return res;\n}\n\n/*\nfloat linearize(in float z) {\n  float A = pMatrix[2].z, B = pMatrix[3].z;\n  float n = - B / (1.0 - A); // camera z near\n  float f =   B / (1.0 + A); // camera z far\n  return (2.0 * n) / (f + n - z * (f - n));\n}\n*/\n\nfloat unpack_depth(const in vec4 rgba_depth)\n{\n  const vec4 bit_shift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\n  float depth = dot(rgba_depth, bit_shift);\n  return depth;\n}\n\n          #endif\n\n\nfloat dp_lookup() {\n  float map_depth, depth;\n  vec4 rgba_depth;\n      \n  if (vDP0.w > 0.0) {\n    rgba_depth = texture2D(SHADOWMAP0, vDP0.xy);\n    depth = vDP1.w;//P0.z;\n  } else {\n    rgba_depth = texture2D(SHADOWMAP1, vDP1.xy);\n    depth = vDP1.w;//P1.z;\n  }\n      \n      \n  map_depth = unpack_depth(rgba_depth);\n      \n  if (map_depth + 0.00005 < depth) return 0.0;\n  else return 1.0;\n}\n      \nfloat pcf_lookup(float s, vec2 offset) {\n  /*\n    s is the projected depth of the current vShadowCoord relative to the shadow's camera. This represents\n    a *potentially* shadowed surface about to be drawn.\n    \n    d is the actual depth stored within the SHADOWMAP texture (representing the visible surface).\n  \n    if the surface to be drawn is further back than the light-visible surface, then the surface is\n    shadowed because it has a greater depth. Less-or-equal depth means it's either in front of, or it *is*\n    the light-visible surface.\n  */\n  vec2 texcoord = (vShadowCoord.xy/vShadowCoord.w)+offset;\n  vec4 rgba_depth = texture2D(SHADOWMAP0, texcoord);\n  float d = unpack_depth(rgba_depth);\n  return (s - d > 0.00002) ? 0.0 : 1.0;\n}\n\nvoid main(inout vec4 ambient, inout vec4 diffuse, inout vec4 specular) {\n//ambient = vec4(0);\n  if (PASS_TYPE == <%=Jax.Scene.AMBIENT_PASS%> || !SHADOWMAP_ENABLED) return;\n  float visibility = 1.0;\n  float s = vShadowCoord.z / vShadowCoord.w;\n  if (LIGHT_TYPE == <%=Jax.POINT_LIGHT%>) {\n    visibility = dp_lookup();\n  } else {\n    vec2 offset = vec2(0.0, 0.0);\n    if (!SHADOWMAP_PCF_ENABLED)\n      visibility = pcf_lookup(s, offset);\n    else {\n      // do PCF filtering\n      float dx, dy;\n      visibility = 0.0;\n      for (float dx = -1.5; dx <= 1.5; dx += 1.0)\n        for (float dy = -1.5; dy <= 1.5; dy += 1.0) {\n          offset.x = dx/2048.0;\n          offset.y = dy/2048.0;\n          visibility += pcf_lookup(s, offset);\n        }\n      visibility /= 16.0;\n    }\n  }\n\n  diffuse *= visibility;\n  specular *= visibility;\n}\n",
  vertex:"void main(void) {\n  if (PASS_TYPE == <%=Jax.Scene.AMBIENT_PASS%> || !SHADOWMAP_ENABLED) return;\n\n  vShadowCoord = SHADOWMAP_MATRIX * mMatrix * VERTEX_POSITION;\n  \n//  if (LIGHT.type == <%=Jax.POINT_LIGHT%>) {\n    /* Perform dual-paraboloid shadow map calculations - for point lights only */\n    vec4 p = vShadowCoord;\n    vec3 pos = p.xyz / p.w;\n          \n    float L = length(pos.xyz);\n    vDP0.xyz = pos / L;\n    vDP1.xyz = pos / L;\n      \n    vDP0.w = pos.z;    \n    //vDPz = pos.z;\n          \n    vDP0.z = 1.0 + vDP0.z;\n    vDP0.x /= vDP0.z;\n    vDP0.y /= vDP0.z;\n    vDP0.z = (L - DP_SHADOW_NEAR) / (DP_SHADOW_FAR - DP_SHADOW_NEAR);\n          \n    vDP0.x =  0.5 * vDP0.x + 0.5;\n    vDP0.y =  0.5 * vDP0.y + 0.5;\n          \n    vDP1.z = 1.0 - vDP1.z;\n    vDP1.x /= vDP1.z;\n    vDP1.y /= vDP1.z;\n    vDP1.z = (L - DP_SHADOW_NEAR) / (DP_SHADOW_FAR - DP_SHADOW_NEAR);\n      \n    vDP1.x =  0.5 * vDP1.x + 0.5;\n    vDP1.y =  0.5 * vDP1.y + 0.5;\n          \n    float map_depth, depth;\n    vec4 rgba_depth;\n      \n    if (vDP0.w > 0.0) {    \n    //if (vDPz > 0.0) {\n      vDP1.w = vDP0.z;\n      //vDPDepth = vDP0.z;\n    } else {\n      vDP1.w = vDP1.z;\n      //vDPDepth = vDP1.z;\n    }\n//  }\n}\n",
exports: {},
name: "shadow_map"});
Jax.shaders['texture'] = new Jax.Shader({  common:"uniform sampler2D Texture;\nuniform float TextureScaleX, TextureScaleY;\n\nshared varying vec2 vTexCoords;\n",
  fragment:"void main(inout vec4 ambient, inout vec4 diffuse, inout vec4 specular) {\n  vec4 t = texture2D(Texture, vTexCoords * vec2(TextureScaleX, TextureScaleY));\n\n  ambient  *= t;\n  diffuse  *= t;\n  specular *= t;\n \n  ambient.a  *= t.a;\n  diffuse.a  *= t.a;\n  specular.a *= t.a;\n}\n",
  vertex:"shared attribute vec4 VERTEX_POSITION;\nshared attribute vec2 VERTEX_TEXCOORDS;\n\nshared uniform mat4 mvMatrix, pMatrix;\n\nvoid main(void) {\n  gl_Position = pMatrix * mvMatrix * VERTEX_POSITION;\n  vTexCoords = VERTEX_TEXCOORDS;\n}\n",
exports: {},
name: "texture"});
Jax.shaders['electrical'] = new Jax.Shader({  common:"// Shared variables save on graphics memory and allow you to \"piggy-back\" off of\n// variables defined in other shaders:\n\nshared uniform mat3 nMatrix;\nshared uniform mat4 mvMatrix, pMatrix;\n\nshared varying vec2 vTexCoords;\nshared varying vec3 vNormal;\nshared varying vec4 vBaseColor;\nvarying vec3 vPos;\n\n// If a variable isn't shared, it will be defined specifically for this shader.\n// If this shader is used twice in one materials, unshared variables will be\n// defined twice -- once for each use of the shader.\n\n//   uniform sampler2D Texture;\n//   uniform float TextureScaleX, TextureScaleY;\n",
  fragment:"          #ifndef dependency_functions_noise\n          #define dependency_functions_noise\n      \n          /*\n * 2D, 3D and 4D Perlin noise, classic and simplex, in a GLSL fragment shader.\n *\n * Classic noise is implemented by the functions:\n * float noise(vec2 P)\n * float noise(vec3 P)\n * float noise(vec4 P)\n *\n * Simplex noise is implemented by the functions:\n * float snoise(vec2 P)\n * float snoise(vec3 P)\n * float snoise(vec4 P)\n *\n * Author: Stefan Gustavson ITN-LiTH (stegu@itn.liu.se) 2004-12-05\n * You may use, modify and redistribute this code free of charge,\n * provided that my name and this notice appears intact.\n */\n\n/*\n * NOTE: there is a formal problem with the dependent texture lookups.\n * A texture coordinate of exactly 1.0 will wrap to 0.0, so strictly speaking,\n * an error occurs every 256 units of the texture domain, and the same gradient\n * is used for two adjacent noise cells. One solution is to set the texture\n * wrap mode to \"CLAMP\" and do the wrapping explicitly in GLSL with the \"mod\"\n * operator. This could also give you noise with repetition intervals other\n * than 256 without any extra cost.\n * This error is not even noticeable to the eye even if you isolate the exact\n * position in the domain where it occurs and know exactly what to look for.\n * The noise pattern is still visually correct, so I left the bug in there.\n * \n * The value of classic 4D noise goes above 1.0 and below -1.0 at some\n * points. Not much and only very sparsely, but it happens.\n */\n\n\n/*\n * \"permTexture\" is a 256x256 texture that is used for both the permutations\n * and the 2D and 3D gradient lookup. For details, see the main C program.\n * \"simplexTexture\" is a small look-up table to determine a simplex traversal\n * order for 3D and 4D simplex noise. Details are in the C program.\n * \"gradTexture\" is a 256x256 texture with 4D gradients, similar to\n * \"permTexture\" but with the permutation index in the alpha component\n * replaced by the w component of the 4D gradient.\n * 2D classic noise uses only permTexture.\n * 2D simplex noise uses permTexture and simplexTexture.\n * 3D classic noise uses only permTexture.\n * 3D simplex noise uses permTexture and simplexTexture.\n * 4D classic noise uses permTexture and gradTexture.\n * 4D simplex noise uses all three textures.\n */\nuniform sampler2D permTexture;\n// sampler1D not supported in WebGL\n//uniform sampler1D simplexTexture;\nuniform sampler2D simplexTexture;\nuniform sampler2D gradTexture;\nuniform float time; // Used for texture animation\n\n/*\n * Both 2D and 3D texture coordinates are defined, for testing purposes.\n */\n//varying vec2 v_texCoord2D;\n//varying vec3 v_texCoord3D;\n//varying vec4 v_color;\n\n/*\n * To create offsets of one texel and one half texel in the\n * texture lookup, we need to know the texture image size.\n */\n#define ONE 0.00390625\n#define ONEHALF 0.001953125\n// The numbers above are 1/256 and 0.5/256, change accordingly\n// if you change the code to use another texture size.\n\n\n/*\n * The interpolation function. This could be a 1D texture lookup\n * to get some more speed, but it's not the main part of the algorithm.\n */\nfloat fade(float t) {\n  // return t*t*(3.0-2.0*t); // Old fade, yields discontinuous second derivative\n  return t*t*t*(t*(t*6.0-15.0)+10.0); // Improved fade, yields C2-continuous noise\n}\n\n\n/*\n * 2D classic Perlin noise. Fast, but less useful than 3D noise.\n */\nfloat noise(vec2 P)\n{\n  vec2 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled and offset for texture lookup\n  vec2 Pf = fract(P);             // Fractional part for interpolation\n\n  // Noise contribution from lower left corner\n  vec2 grad00 = texture2D(permTexture, Pi).rg * 4.0 - 1.0;\n  float n00 = dot(grad00, Pf);\n\n  // Noise contribution from lower right corner\n  vec2 grad10 = texture2D(permTexture, Pi + vec2(ONE, 0.0)).rg * 4.0 - 1.0;\n  float n10 = dot(grad10, Pf - vec2(1.0, 0.0));\n\n  // Noise contribution from upper left corner\n  vec2 grad01 = texture2D(permTexture, Pi + vec2(0.0, ONE)).rg * 4.0 - 1.0;\n  float n01 = dot(grad01, Pf - vec2(0.0, 1.0));\n\n  // Noise contribution from upper right corner\n  vec2 grad11 = texture2D(permTexture, Pi + vec2(ONE, ONE)).rg * 4.0 - 1.0;\n  float n11 = dot(grad11, Pf - vec2(1.0, 1.0));\n\n  // Blend contributions along x\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade(Pf.x));\n\n  // Blend contributions along y\n  float n_xy = mix(n_x.x, n_x.y, fade(Pf.y));\n\n  // We're done, return the final noise value.\n  return n_xy;\n}\n\n\n/*\n * 3D classic noise. Slower, but a lot more useful than 2D noise.\n */\nfloat noise(vec3 P)\n{\n  vec3 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled so +1 moves one texel\n                                  // and offset 1/2 texel to sample texel centers\n  vec3 Pf = fract(P);     // Fractional part for interpolation\n\n  // Noise contributions from (x=0, y=0), z=0 and z=1\n  float perm00 = texture2D(permTexture, Pi.xy).a ;\n  vec3  grad000 = texture2D(permTexture, vec2(perm00, Pi.z)).rgb * 4.0 - 1.0;\n  float n000 = dot(grad000, Pf);\n  vec3  grad001 = texture2D(permTexture, vec2(perm00, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n001 = dot(grad001, Pf - vec3(0.0, 0.0, 1.0));\n\n  // Noise contributions from (x=0, y=1), z=0 and z=1\n  float perm01 = texture2D(permTexture, Pi.xy + vec2(0.0, ONE)).a ;\n  vec3  grad010 = texture2D(permTexture, vec2(perm01, Pi.z)).rgb * 4.0 - 1.0;\n  float n010 = dot(grad010, Pf - vec3(0.0, 1.0, 0.0));\n  vec3  grad011 = texture2D(permTexture, vec2(perm01, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n011 = dot(grad011, Pf - vec3(0.0, 1.0, 1.0));\n\n  // Noise contributions from (x=1, y=0), z=0 and z=1\n  float perm10 = texture2D(permTexture, Pi.xy + vec2(ONE, 0.0)).a ;\n  vec3  grad100 = texture2D(permTexture, vec2(perm10, Pi.z)).rgb * 4.0 - 1.0;\n  float n100 = dot(grad100, Pf - vec3(1.0, 0.0, 0.0));\n  vec3  grad101 = texture2D(permTexture, vec2(perm10, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n101 = dot(grad101, Pf - vec3(1.0, 0.0, 1.0));\n\n  // Noise contributions from (x=1, y=1), z=0 and z=1\n  float perm11 = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a ;\n  vec3  grad110 = texture2D(permTexture, vec2(perm11, Pi.z)).rgb * 4.0 - 1.0;\n  float n110 = dot(grad110, Pf - vec3(1.0, 1.0, 0.0));\n  vec3  grad111 = texture2D(permTexture, vec2(perm11, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n111 = dot(grad111, Pf - vec3(1.0, 1.0, 1.0));\n\n  // Blend contributions along x\n  vec4 n_x = mix(vec4(n000, n001, n010, n011),\n                 vec4(n100, n101, n110, n111), fade(Pf.x));\n\n  // Blend contributions along y\n  vec2 n_xy = mix(n_x.xy, n_x.zw, fade(Pf.y));\n\n  // Blend contributions along z\n  float n_xyz = mix(n_xy.x, n_xy.y, fade(Pf.z));\n\n  // We're done, return the final noise value.\n  return n_xyz;\n}\n\n\n/*\n * 4D classic noise. Slow, but very useful. 4D simplex noise is a lot faster.\n *\n * This function performs 8 texture lookups and 16 dependent texture lookups,\n * 16 dot products, 4 mix operations and a lot of additions and multiplications.\n * Needless to say, it's not super fast. But it's not dead slow either.\n */\nfloat noise(vec4 P)\n{\n  vec4 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled so +1 moves one texel\n                                  // and offset 1/2 texel to sample texel centers\n  vec4 Pf = fract(P);      // Fractional part for interpolation\n\n  // \"n0000\" is the noise contribution from (x=0, y=0, z=0, w=0), and so on\n  float perm00xy = texture2D(permTexture, Pi.xy).a ;\n  float perm00zw = texture2D(permTexture, Pi.zw).a ;\n  vec4 grad0000 = texture2D(gradTexture, vec2(perm00xy, perm00zw)).rgba * 4.0 -1.0;\n  float n0000 = dot(grad0000, Pf);\n\n  float perm01zw = texture2D(permTexture, Pi.zw  + vec2(0.0, ONE)).a ;\n  vec4  grad0001 = texture2D(gradTexture, vec2(perm00xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n0001 = dot(grad0001, Pf - vec4(0.0, 0.0, 0.0, 1.0));\n\n  float perm10zw = texture2D(permTexture, Pi.zw  + vec2(ONE, 0.0)).a ;\n  vec4  grad0010 = texture2D(gradTexture, vec2(perm00xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n0010 = dot(grad0010, Pf - vec4(0.0, 0.0, 1.0, 0.0));\n\n  float perm11zw = texture2D(permTexture, Pi.zw  + vec2(ONE, ONE)).a ;\n  vec4  grad0011 = texture2D(gradTexture, vec2(perm00xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n0011 = dot(grad0011, Pf - vec4(0.0, 0.0, 1.0, 1.0));\n\n  float perm01xy = texture2D(permTexture, Pi.xy + vec2(0.0, ONE)).a ;\n  vec4  grad0100 = texture2D(gradTexture, vec2(perm01xy, perm00zw)).rgba * 4.0 - 1.0;\n  float n0100 = dot(grad0100, Pf - vec4(0.0, 1.0, 0.0, 0.0));\n\n  vec4  grad0101 = texture2D(gradTexture, vec2(perm01xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n0101 = dot(grad0101, Pf - vec4(0.0, 1.0, 0.0, 1.0));\n\n  vec4  grad0110 = texture2D(gradTexture, vec2(perm01xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n0110 = dot(grad0110, Pf - vec4(0.0, 1.0, 1.0, 0.0));\n\n  vec4  grad0111 = texture2D(gradTexture, vec2(perm01xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n0111 = dot(grad0111, Pf - vec4(0.0, 1.0, 1.0, 1.0));\n\n  float perm10xy = texture2D(permTexture, Pi.xy + vec2(ONE, 0.0)).a ;\n  vec4  grad1000 = texture2D(gradTexture, vec2(perm10xy, perm00zw)).rgba * 4.0 - 1.0;\n  float n1000 = dot(grad1000, Pf - vec4(1.0, 0.0, 0.0, 0.0));\n\n  vec4  grad1001 = texture2D(gradTexture, vec2(perm10xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n1001 = dot(grad1001, Pf - vec4(1.0, 0.0, 0.0, 1.0));\n\n  vec4  grad1010 = texture2D(gradTexture, vec2(perm10xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n1010 = dot(grad1010, Pf - vec4(1.0, 0.0, 1.0, 0.0));\n\n  vec4  grad1011 = texture2D(gradTexture, vec2(perm10xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n1011 = dot(grad1011, Pf - vec4(1.0, 0.0, 1.0, 1.0));\n\n  float perm11xy = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a ;\n  vec4  grad1100 = texture2D(gradTexture, vec2(perm11xy, perm00zw)).rgba * 4.0 - 1.0;\n  float n1100 = dot(grad1100, Pf - vec4(1.0, 1.0, 0.0, 0.0));\n\n  vec4  grad1101 = texture2D(gradTexture, vec2(perm11xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n1101 = dot(grad1101, Pf - vec4(1.0, 1.0, 0.0, 1.0));\n\n  vec4  grad1110 = texture2D(gradTexture, vec2(perm11xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n1110 = dot(grad1110, Pf - vec4(1.0, 1.0, 1.0, 0.0));\n\n  vec4  grad1111 = texture2D(gradTexture, vec2(perm11xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n1111 = dot(grad1111, Pf - vec4(1.0, 1.0, 1.0, 1.0));\n\n  // Blend contributions along x\n  float fadex = fade(Pf.x);\n  vec4 n_x0 = mix(vec4(n0000, n0001, n0010, n0011),\n                  vec4(n1000, n1001, n1010, n1011), fadex);\n  vec4 n_x1 = mix(vec4(n0100, n0101, n0110, n0111),\n                  vec4(n1100, n1101, n1110, n1111), fadex);\n\n  // Blend contributions along y\n  vec4 n_xy = mix(n_x0, n_x1, fade(Pf.y));\n\n  // Blend contributions along z\n  vec2 n_xyz = mix(n_xy.xy, n_xy.zw, fade(Pf.z));\n\n  // Blend contributions along w\n  float n_xyzw = mix(n_xyz.x, n_xyz.y, fade(Pf.w));\n\n  // We're done, return the final noise value.\n  return n_xyzw;\n}\n\n\n/*\n * 2D simplex noise. Somewhat slower but much better looking than classic noise.\n */\nfloat snoise(vec2 P) {\n\n// Skew and unskew factors are a bit hairy for 2D, so define them as constants\n// This is (sqrt(3.0)-1.0)/2.0\n#define F2 0.366025403784\n// This is (3.0-sqrt(3.0))/6.0\n#define G2 0.211324865405\n\n  // Skew the (x,y) space to determine which cell of 2 simplices we're in\n \tfloat s = (P.x + P.y) * F2;   // Hairy factor for 2D skewing\n  vec2 Pi = floor(P + s);\n  float t = (Pi.x + Pi.y) * G2; // Hairy factor for unskewing\n  vec2 P0 = Pi - t; // Unskew the cell origin back to (x,y) space\n  Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n\n  vec2 Pf0 = P - P0;  // The x,y distances from the cell origin\n\n  // For the 2D case, the simplex shape is an equilateral triangle.\n  // Find out whether we are above or below the x=y diagonal to\n  // determine which of the two triangles we're in.\n  vec2 o1;\n  if(Pf0.x > Pf0.y) o1 = vec2(1.0, 0.0);  // +x, +y traversal order\n  else o1 = vec2(0.0, 1.0);               // +y, +x traversal order\n\n  // Noise contribution from simplex origin\n  vec2 grad0 = texture2D(permTexture, Pi).rg * 4.0 - 1.0;\n  float t0 = 0.5 - dot(Pf0, Pf0);\n  float n0;\n  if (t0 < 0.0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * dot(grad0, Pf0);\n  }\n\n  // Noise contribution from middle corner\n  vec2 Pf1 = Pf0 - o1 + G2;\n  vec2 grad1 = texture2D(permTexture, Pi + o1*ONE).rg * 4.0 - 1.0;\n  float t1 = 0.5 - dot(Pf1, Pf1);\n  float n1;\n  if (t1 < 0.0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * dot(grad1, Pf1);\n  }\n  \n  // Noise contribution from last corner\n  vec2 Pf2 = Pf0 - vec2(1.0-2.0*G2);\n  vec2 grad2 = texture2D(permTexture, Pi + vec2(ONE, ONE)).rg * 4.0 - 1.0;\n  float t2 = 0.5 - dot(Pf2, Pf2);\n  float n2;\n  if(t2 < 0.0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * dot(grad2, Pf2);\n  }\n\n  // Sum up and scale the result to cover the range [-1,1]\n  return 70.0 * (n0 + n1 + n2);\n}\n\n\n/*\n * 3D simplex noise. Comparable in speed to classic noise, better looking.\n */\nfloat snoise(vec3 P) {\n\n// The skewing and unskewing factors are much simpler for the 3D case\n#define F3 0.333333333333\n#define G3 0.166666666667\n\n  // Skew the (x,y,z) space to determine which cell of 6 simplices we're in\n \tfloat s = (P.x + P.y + P.z) * F3; // Factor for 3D skewing\n  vec3 Pi = floor(P + s);\n  float t = (Pi.x + Pi.y + Pi.z) * G3;\n  vec3 P0 = Pi - t; // Unskew the cell origin back to (x,y,z) space\n  Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n\n  vec3 Pf0 = P - P0;  // The x,y distances from the cell origin\n\n  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n  // To find out which of the six possible tetrahedra we're in, we need to\n  // determine the magnitude ordering of x, y and z components of Pf0.\n  // The method below is explained briefly in the C code. It uses a small\n  // 1D texture as a lookup table. The table is designed to work for both\n  // 3D and 4D noise, so only 8 (only 6, actually) of the 64 indices are\n  // used here.\n  float c1 = (Pf0.x > Pf0.y) ? 0.5078125 : 0.0078125; // 1/2 + 1/128\n  float c2 = (Pf0.x > Pf0.z) ? 0.25 : 0.0;\n  float c3 = (Pf0.y > Pf0.z) ? 0.125 : 0.0;\n  float sindex = c1 + c2 + c3;\n  vec3 offsets = texture2D(simplexTexture, vec2(sindex, 0.0)).rgb;\n//  vec3 offsets = texture1D(simplexTexture, sindex).rgb;\n  vec3 o1 = step(0.375, offsets);\n  vec3 o2 = step(0.125, offsets);\n\n  // Noise contribution from simplex origin\n  float perm0 = texture2D(permTexture, Pi.xy).a;\n  vec3  grad0 = texture2D(permTexture, vec2(perm0, Pi.z)).rgb * 4.0 - 1.0;\n  float t0 = 0.6 - dot(Pf0, Pf0);\n  float n0;\n  if (t0 < 0.0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * dot(grad0, Pf0);\n  }\n\n  // Noise contribution from second corner\n  vec3 Pf1 = Pf0 - o1 + G3;\n  float perm1 = texture2D(permTexture, Pi.xy + o1.xy*ONE).a;\n  vec3  grad1 = texture2D(permTexture, vec2(perm1, Pi.z + o1.z*ONE)).rgb * 4.0 - 1.0;\n  float t1 = 0.6 - dot(Pf1, Pf1);\n  float n1;\n  if (t1 < 0.0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * dot(grad1, Pf1);\n  }\n  \n  // Noise contribution from third corner\n  vec3 Pf2 = Pf0 - o2 + 2.0 * G3;\n  float perm2 = texture2D(permTexture, Pi.xy + o2.xy*ONE).a;\n  vec3  grad2 = texture2D(permTexture, vec2(perm2, Pi.z + o2.z*ONE)).rgb * 4.0 - 1.0;\n  float t2 = 0.6 - dot(Pf2, Pf2);\n  float n2;\n  if (t2 < 0.0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * dot(grad2, Pf2);\n  }\n  \n  // Noise contribution from last corner\n  vec3 Pf3 = Pf0 - vec3(1.0-3.0*G3);\n  float perm3 = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;\n  vec3  grad3 = texture2D(permTexture, vec2(perm3, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float t3 = 0.6 - dot(Pf3, Pf3);\n  float n3;\n  if(t3 < 0.0) n3 = 0.0;\n  else {\n    t3 *= t3;\n    n3 = t3 * t3 * dot(grad3, Pf3);\n  }\n\n  // Sum up and scale the result to cover the range [-1,1]\n  return 32.0 * (n0 + n1 + n2 + n3);\n}\n\n\n/*\n * 4D simplex noise. A lot faster than classic 4D noise, and better looking.\n */\n\nfloat snoise(vec4 P) {\n\n// The skewing and unskewing factors are hairy again for the 4D case\n// This is (sqrt(5.0)-1.0)/4.0\n#define F4 0.309016994375\n// This is (5.0-sqrt(5.0))/20.0\n#define G4 0.138196601125\n\n  // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n \tfloat s = (P.x + P.y + P.z + P.w) * F4; // Factor for 4D skewing\n  vec4 Pi = floor(P + s);\n  float t = (Pi.x + Pi.y + Pi.z + Pi.w) * G4;\n  vec4 P0 = Pi - t; // Unskew the cell origin back to (x,y,z,w) space\n  Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n\n  vec4 Pf0 = P - P0;  // The x,y distances from the cell origin\n\n  // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n  // To find out which of the 24 possible simplices we're in, we need to\n  // determine the magnitude ordering of x, y, z and w components of Pf0.\n  // The method below is presented without explanation. It uses a small 1D\n  // texture as a lookup table. The table is designed to work for both\n  // 3D and 4D noise and contains 64 indices, of which only 24 are actually\n  // used. An extension to 5D would require a larger texture here.\n  float c1 = (Pf0.x > Pf0.y) ? 0.5078125 : 0.0078125; // 1/2 + 1/128\n  float c2 = (Pf0.x > Pf0.z) ? 0.25 : 0.0;\n  float c3 = (Pf0.y > Pf0.z) ? 0.125 : 0.0;\n  float c4 = (Pf0.x > Pf0.w) ? 0.0625 : 0.0;\n  float c5 = (Pf0.y > Pf0.w) ? 0.03125 : 0.0;\n  float c6 = (Pf0.z > Pf0.w) ? 0.015625 : 0.0;\n  float sindex = c1 + c2 + c3 + c4 + c5 + c6;\n  vec4 offsets = texture2D(simplexTexture, vec2(sindex, 0.0)).rgba;\n//  vec4 offsets = texture1D(simplexTexture, sindex).rgba;\n  vec4 o1 = step(0.625, offsets);\n  vec4 o2 = step(0.375, offsets);\n  vec4 o3 = step(0.125, offsets);\n\n  // Noise contribution from simplex origin\n  float perm0xy = texture2D(permTexture, Pi.xy).a;\n  float perm0zw = texture2D(permTexture, Pi.zw).a;\n  vec4  grad0 = texture2D(gradTexture, vec2(perm0xy, perm0zw)).rgba * 4.0 - 1.0;\n  float t0 = 0.6 - dot(Pf0, Pf0);\n  float n0;\n  if (t0 < 0.0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * dot(grad0, Pf0);\n  }\n\n  // Noise contribution from second corner\n  vec4 Pf1 = Pf0 - o1 + G4;\n  o1 = o1 * ONE;\n  float perm1xy = texture2D(permTexture, Pi.xy + o1.xy).a;\n  float perm1zw = texture2D(permTexture, Pi.zw + o1.zw).a;\n  vec4  grad1 = texture2D(gradTexture, vec2(perm1xy, perm1zw)).rgba * 4.0 - 1.0;\n  float t1 = 0.6 - dot(Pf1, Pf1);\n  float n1;\n  if (t1 < 0.0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * dot(grad1, Pf1);\n  }\n  \n  // Noise contribution from third corner\n  vec4 Pf2 = Pf0 - o2 + 2.0 * G4;\n  o2 = o2 * ONE;\n  float perm2xy = texture2D(permTexture, Pi.xy + o2.xy).a;\n  float perm2zw = texture2D(permTexture, Pi.zw + o2.zw).a;\n  vec4  grad2 = texture2D(gradTexture, vec2(perm2xy, perm2zw)).rgba * 4.0 - 1.0;\n  float t2 = 0.6 - dot(Pf2, Pf2);\n  float n2;\n  if (t2 < 0.0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * dot(grad2, Pf2);\n  }\n  \n  // Noise contribution from fourth corner\n  vec4 Pf3 = Pf0 - o3 + 3.0 * G4;\n  o3 = o3 * ONE;\n  float perm3xy = texture2D(permTexture, Pi.xy + o3.xy).a;\n  float perm3zw = texture2D(permTexture, Pi.zw + o3.zw).a;\n  vec4  grad3 = texture2D(gradTexture, vec2(perm3xy, perm3zw)).rgba * 4.0 - 1.0;\n  float t3 = 0.6 - dot(Pf3, Pf3);\n  float n3;\n  if (t3 < 0.0) n3 = 0.0;\n  else {\n    t3 *= t3;\n    n3 = t3 * t3 * dot(grad3, Pf3);\n  }\n  \n  // Noise contribution from last corner\n  vec4 Pf4 = Pf0 - vec4(1.0-4.0*G4);\n  float perm4xy = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;\n  float perm4zw = texture2D(permTexture, Pi.zw + vec2(ONE, ONE)).a;\n  vec4  grad4 = texture2D(gradTexture, vec2(perm4xy, perm4zw)).rgba * 4.0 - 1.0;\n  float t4 = 0.6 - dot(Pf4, Pf4);\n  float n4;\n  if(t4 < 0.0) n4 = 0.0;\n  else {\n    t4 *= t4;\n    n4 = t4 * t4 * dot(grad4, Pf4);\n  }\n\n  // Sum up and scale the result to cover the range [-1,1]\n  return 27.0 * (n0 + n1 + n2 + n3 + n4);\n}\n\n          #endif\n\n\nuniform float TIME;\n\nvec3 VeinColor = vec3(0.6,0.6,1.0);\n\nvoid main(inout vec4 ambient, inout vec4 diffuse, inout vec4 specular) {\n  float n = abs(snoise(vec4(vPos/4.0, TIME)) - 0.25) + \n                 abs(snoise(vec4(vPos/2.0, TIME)) - 0.125) + \n                 abs(snoise(vec4(vPos, TIME)) - 0.0625) + \n                 abs(snoise(vec4(vPos*2.0, TIME)) - 0.03125);\n                 \n  float sineval = sin(vPos.y + n) * 0.5 + 0.5;\n  \n  ambient.rgb = mix(VeinColor, ambient.rgb, sineval) * 2.0;\n  // not illuminated by lights... the ambient component is its own\n  diffuse = specular = vec4(0);\n}\n",
  vertex:"shared attribute vec4 VERTEX_POSITION, VERTEX_COLOR;\nshared attribute vec3 VERTEX_NORMAL;\nshared attribute vec2 VERTEX_TEXCOORDS;\n\nvoid main(void) {\n  gl_Position = pMatrix * mvMatrix * VERTEX_POSITION;\n  vPos = VERTEX_POSITION.xyz;\n//  vNormal = VERTEX_NORMAL;\n//  vColor = VERTEX_COLOR;\n//  vTexCoords = VERTEX_TEXCOORDS;\n}\n",
exports: {},
name: "electrical"});
Jax.shaders['granite'] = new Jax.Shader({  common:"varying vec3 vPos;\n// Shared variables save on graphics memory and allow you to \"piggy-back\" off of\n// variables defined in other shaders:\n\nshared uniform mat3 nMatrix;\nshared uniform mat4 mvMatrix, pMatrix;\n\nshared varying vec2 vTexCoords;\nshared varying vec3 vNormal;\nshared varying vec4 vBaseColor;\n\n// If a variable isn't shared, it will be defined specifically for this shader.\n// If this shader is used twice in one materials, unshared variables will be\n// defined twice -- once for each use of the shader.\n\n//   uniform sampler2D Texture;\n//   uniform float TextureScaleX, TextureScaleY;\n",
  fragment:"          #ifndef dependency_functions_noise\n          #define dependency_functions_noise\n      \n          /*\n * 2D, 3D and 4D Perlin noise, classic and simplex, in a GLSL fragment shader.\n *\n * Classic noise is implemented by the functions:\n * float noise(vec2 P)\n * float noise(vec3 P)\n * float noise(vec4 P)\n *\n * Simplex noise is implemented by the functions:\n * float snoise(vec2 P)\n * float snoise(vec3 P)\n * float snoise(vec4 P)\n *\n * Author: Stefan Gustavson ITN-LiTH (stegu@itn.liu.se) 2004-12-05\n * You may use, modify and redistribute this code free of charge,\n * provided that my name and this notice appears intact.\n */\n\n/*\n * NOTE: there is a formal problem with the dependent texture lookups.\n * A texture coordinate of exactly 1.0 will wrap to 0.0, so strictly speaking,\n * an error occurs every 256 units of the texture domain, and the same gradient\n * is used for two adjacent noise cells. One solution is to set the texture\n * wrap mode to \"CLAMP\" and do the wrapping explicitly in GLSL with the \"mod\"\n * operator. This could also give you noise with repetition intervals other\n * than 256 without any extra cost.\n * This error is not even noticeable to the eye even if you isolate the exact\n * position in the domain where it occurs and know exactly what to look for.\n * The noise pattern is still visually correct, so I left the bug in there.\n * \n * The value of classic 4D noise goes above 1.0 and below -1.0 at some\n * points. Not much and only very sparsely, but it happens.\n */\n\n\n/*\n * \"permTexture\" is a 256x256 texture that is used for both the permutations\n * and the 2D and 3D gradient lookup. For details, see the main C program.\n * \"simplexTexture\" is a small look-up table to determine a simplex traversal\n * order for 3D and 4D simplex noise. Details are in the C program.\n * \"gradTexture\" is a 256x256 texture with 4D gradients, similar to\n * \"permTexture\" but with the permutation index in the alpha component\n * replaced by the w component of the 4D gradient.\n * 2D classic noise uses only permTexture.\n * 2D simplex noise uses permTexture and simplexTexture.\n * 3D classic noise uses only permTexture.\n * 3D simplex noise uses permTexture and simplexTexture.\n * 4D classic noise uses permTexture and gradTexture.\n * 4D simplex noise uses all three textures.\n */\nuniform sampler2D permTexture;\n// sampler1D not supported in WebGL\n//uniform sampler1D simplexTexture;\nuniform sampler2D simplexTexture;\nuniform sampler2D gradTexture;\nuniform float time; // Used for texture animation\n\n/*\n * Both 2D and 3D texture coordinates are defined, for testing purposes.\n */\n//varying vec2 v_texCoord2D;\n//varying vec3 v_texCoord3D;\n//varying vec4 v_color;\n\n/*\n * To create offsets of one texel and one half texel in the\n * texture lookup, we need to know the texture image size.\n */\n#define ONE 0.00390625\n#define ONEHALF 0.001953125\n// The numbers above are 1/256 and 0.5/256, change accordingly\n// if you change the code to use another texture size.\n\n\n/*\n * The interpolation function. This could be a 1D texture lookup\n * to get some more speed, but it's not the main part of the algorithm.\n */\nfloat fade(float t) {\n  // return t*t*(3.0-2.0*t); // Old fade, yields discontinuous second derivative\n  return t*t*t*(t*(t*6.0-15.0)+10.0); // Improved fade, yields C2-continuous noise\n}\n\n\n/*\n * 2D classic Perlin noise. Fast, but less useful than 3D noise.\n */\nfloat noise(vec2 P)\n{\n  vec2 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled and offset for texture lookup\n  vec2 Pf = fract(P);             // Fractional part for interpolation\n\n  // Noise contribution from lower left corner\n  vec2 grad00 = texture2D(permTexture, Pi).rg * 4.0 - 1.0;\n  float n00 = dot(grad00, Pf);\n\n  // Noise contribution from lower right corner\n  vec2 grad10 = texture2D(permTexture, Pi + vec2(ONE, 0.0)).rg * 4.0 - 1.0;\n  float n10 = dot(grad10, Pf - vec2(1.0, 0.0));\n\n  // Noise contribution from upper left corner\n  vec2 grad01 = texture2D(permTexture, Pi + vec2(0.0, ONE)).rg * 4.0 - 1.0;\n  float n01 = dot(grad01, Pf - vec2(0.0, 1.0));\n\n  // Noise contribution from upper right corner\n  vec2 grad11 = texture2D(permTexture, Pi + vec2(ONE, ONE)).rg * 4.0 - 1.0;\n  float n11 = dot(grad11, Pf - vec2(1.0, 1.0));\n\n  // Blend contributions along x\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade(Pf.x));\n\n  // Blend contributions along y\n  float n_xy = mix(n_x.x, n_x.y, fade(Pf.y));\n\n  // We're done, return the final noise value.\n  return n_xy;\n}\n\n\n/*\n * 3D classic noise. Slower, but a lot more useful than 2D noise.\n */\nfloat noise(vec3 P)\n{\n  vec3 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled so +1 moves one texel\n                                  // and offset 1/2 texel to sample texel centers\n  vec3 Pf = fract(P);     // Fractional part for interpolation\n\n  // Noise contributions from (x=0, y=0), z=0 and z=1\n  float perm00 = texture2D(permTexture, Pi.xy).a ;\n  vec3  grad000 = texture2D(permTexture, vec2(perm00, Pi.z)).rgb * 4.0 - 1.0;\n  float n000 = dot(grad000, Pf);\n  vec3  grad001 = texture2D(permTexture, vec2(perm00, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n001 = dot(grad001, Pf - vec3(0.0, 0.0, 1.0));\n\n  // Noise contributions from (x=0, y=1), z=0 and z=1\n  float perm01 = texture2D(permTexture, Pi.xy + vec2(0.0, ONE)).a ;\n  vec3  grad010 = texture2D(permTexture, vec2(perm01, Pi.z)).rgb * 4.0 - 1.0;\n  float n010 = dot(grad010, Pf - vec3(0.0, 1.0, 0.0));\n  vec3  grad011 = texture2D(permTexture, vec2(perm01, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n011 = dot(grad011, Pf - vec3(0.0, 1.0, 1.0));\n\n  // Noise contributions from (x=1, y=0), z=0 and z=1\n  float perm10 = texture2D(permTexture, Pi.xy + vec2(ONE, 0.0)).a ;\n  vec3  grad100 = texture2D(permTexture, vec2(perm10, Pi.z)).rgb * 4.0 - 1.0;\n  float n100 = dot(grad100, Pf - vec3(1.0, 0.0, 0.0));\n  vec3  grad101 = texture2D(permTexture, vec2(perm10, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n101 = dot(grad101, Pf - vec3(1.0, 0.0, 1.0));\n\n  // Noise contributions from (x=1, y=1), z=0 and z=1\n  float perm11 = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a ;\n  vec3  grad110 = texture2D(permTexture, vec2(perm11, Pi.z)).rgb * 4.0 - 1.0;\n  float n110 = dot(grad110, Pf - vec3(1.0, 1.0, 0.0));\n  vec3  grad111 = texture2D(permTexture, vec2(perm11, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n111 = dot(grad111, Pf - vec3(1.0, 1.0, 1.0));\n\n  // Blend contributions along x\n  vec4 n_x = mix(vec4(n000, n001, n010, n011),\n                 vec4(n100, n101, n110, n111), fade(Pf.x));\n\n  // Blend contributions along y\n  vec2 n_xy = mix(n_x.xy, n_x.zw, fade(Pf.y));\n\n  // Blend contributions along z\n  float n_xyz = mix(n_xy.x, n_xy.y, fade(Pf.z));\n\n  // We're done, return the final noise value.\n  return n_xyz;\n}\n\n\n/*\n * 4D classic noise. Slow, but very useful. 4D simplex noise is a lot faster.\n *\n * This function performs 8 texture lookups and 16 dependent texture lookups,\n * 16 dot products, 4 mix operations and a lot of additions and multiplications.\n * Needless to say, it's not super fast. But it's not dead slow either.\n */\nfloat noise(vec4 P)\n{\n  vec4 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled so +1 moves one texel\n                                  // and offset 1/2 texel to sample texel centers\n  vec4 Pf = fract(P);      // Fractional part for interpolation\n\n  // \"n0000\" is the noise contribution from (x=0, y=0, z=0, w=0), and so on\n  float perm00xy = texture2D(permTexture, Pi.xy).a ;\n  float perm00zw = texture2D(permTexture, Pi.zw).a ;\n  vec4 grad0000 = texture2D(gradTexture, vec2(perm00xy, perm00zw)).rgba * 4.0 -1.0;\n  float n0000 = dot(grad0000, Pf);\n\n  float perm01zw = texture2D(permTexture, Pi.zw  + vec2(0.0, ONE)).a ;\n  vec4  grad0001 = texture2D(gradTexture, vec2(perm00xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n0001 = dot(grad0001, Pf - vec4(0.0, 0.0, 0.0, 1.0));\n\n  float perm10zw = texture2D(permTexture, Pi.zw  + vec2(ONE, 0.0)).a ;\n  vec4  grad0010 = texture2D(gradTexture, vec2(perm00xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n0010 = dot(grad0010, Pf - vec4(0.0, 0.0, 1.0, 0.0));\n\n  float perm11zw = texture2D(permTexture, Pi.zw  + vec2(ONE, ONE)).a ;\n  vec4  grad0011 = texture2D(gradTexture, vec2(perm00xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n0011 = dot(grad0011, Pf - vec4(0.0, 0.0, 1.0, 1.0));\n\n  float perm01xy = texture2D(permTexture, Pi.xy + vec2(0.0, ONE)).a ;\n  vec4  grad0100 = texture2D(gradTexture, vec2(perm01xy, perm00zw)).rgba * 4.0 - 1.0;\n  float n0100 = dot(grad0100, Pf - vec4(0.0, 1.0, 0.0, 0.0));\n\n  vec4  grad0101 = texture2D(gradTexture, vec2(perm01xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n0101 = dot(grad0101, Pf - vec4(0.0, 1.0, 0.0, 1.0));\n\n  vec4  grad0110 = texture2D(gradTexture, vec2(perm01xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n0110 = dot(grad0110, Pf - vec4(0.0, 1.0, 1.0, 0.0));\n\n  vec4  grad0111 = texture2D(gradTexture, vec2(perm01xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n0111 = dot(grad0111, Pf - vec4(0.0, 1.0, 1.0, 1.0));\n\n  float perm10xy = texture2D(permTexture, Pi.xy + vec2(ONE, 0.0)).a ;\n  vec4  grad1000 = texture2D(gradTexture, vec2(perm10xy, perm00zw)).rgba * 4.0 - 1.0;\n  float n1000 = dot(grad1000, Pf - vec4(1.0, 0.0, 0.0, 0.0));\n\n  vec4  grad1001 = texture2D(gradTexture, vec2(perm10xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n1001 = dot(grad1001, Pf - vec4(1.0, 0.0, 0.0, 1.0));\n\n  vec4  grad1010 = texture2D(gradTexture, vec2(perm10xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n1010 = dot(grad1010, Pf - vec4(1.0, 0.0, 1.0, 0.0));\n\n  vec4  grad1011 = texture2D(gradTexture, vec2(perm10xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n1011 = dot(grad1011, Pf - vec4(1.0, 0.0, 1.0, 1.0));\n\n  float perm11xy = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a ;\n  vec4  grad1100 = texture2D(gradTexture, vec2(perm11xy, perm00zw)).rgba * 4.0 - 1.0;\n  float n1100 = dot(grad1100, Pf - vec4(1.0, 1.0, 0.0, 0.0));\n\n  vec4  grad1101 = texture2D(gradTexture, vec2(perm11xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n1101 = dot(grad1101, Pf - vec4(1.0, 1.0, 0.0, 1.0));\n\n  vec4  grad1110 = texture2D(gradTexture, vec2(perm11xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n1110 = dot(grad1110, Pf - vec4(1.0, 1.0, 1.0, 0.0));\n\n  vec4  grad1111 = texture2D(gradTexture, vec2(perm11xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n1111 = dot(grad1111, Pf - vec4(1.0, 1.0, 1.0, 1.0));\n\n  // Blend contributions along x\n  float fadex = fade(Pf.x);\n  vec4 n_x0 = mix(vec4(n0000, n0001, n0010, n0011),\n                  vec4(n1000, n1001, n1010, n1011), fadex);\n  vec4 n_x1 = mix(vec4(n0100, n0101, n0110, n0111),\n                  vec4(n1100, n1101, n1110, n1111), fadex);\n\n  // Blend contributions along y\n  vec4 n_xy = mix(n_x0, n_x1, fade(Pf.y));\n\n  // Blend contributions along z\n  vec2 n_xyz = mix(n_xy.xy, n_xy.zw, fade(Pf.z));\n\n  // Blend contributions along w\n  float n_xyzw = mix(n_xyz.x, n_xyz.y, fade(Pf.w));\n\n  // We're done, return the final noise value.\n  return n_xyzw;\n}\n\n\n/*\n * 2D simplex noise. Somewhat slower but much better looking than classic noise.\n */\nfloat snoise(vec2 P) {\n\n// Skew and unskew factors are a bit hairy for 2D, so define them as constants\n// This is (sqrt(3.0)-1.0)/2.0\n#define F2 0.366025403784\n// This is (3.0-sqrt(3.0))/6.0\n#define G2 0.211324865405\n\n  // Skew the (x,y) space to determine which cell of 2 simplices we're in\n \tfloat s = (P.x + P.y) * F2;   // Hairy factor for 2D skewing\n  vec2 Pi = floor(P + s);\n  float t = (Pi.x + Pi.y) * G2; // Hairy factor for unskewing\n  vec2 P0 = Pi - t; // Unskew the cell origin back to (x,y) space\n  Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n\n  vec2 Pf0 = P - P0;  // The x,y distances from the cell origin\n\n  // For the 2D case, the simplex shape is an equilateral triangle.\n  // Find out whether we are above or below the x=y diagonal to\n  // determine which of the two triangles we're in.\n  vec2 o1;\n  if(Pf0.x > Pf0.y) o1 = vec2(1.0, 0.0);  // +x, +y traversal order\n  else o1 = vec2(0.0, 1.0);               // +y, +x traversal order\n\n  // Noise contribution from simplex origin\n  vec2 grad0 = texture2D(permTexture, Pi).rg * 4.0 - 1.0;\n  float t0 = 0.5 - dot(Pf0, Pf0);\n  float n0;\n  if (t0 < 0.0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * dot(grad0, Pf0);\n  }\n\n  // Noise contribution from middle corner\n  vec2 Pf1 = Pf0 - o1 + G2;\n  vec2 grad1 = texture2D(permTexture, Pi + o1*ONE).rg * 4.0 - 1.0;\n  float t1 = 0.5 - dot(Pf1, Pf1);\n  float n1;\n  if (t1 < 0.0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * dot(grad1, Pf1);\n  }\n  \n  // Noise contribution from last corner\n  vec2 Pf2 = Pf0 - vec2(1.0-2.0*G2);\n  vec2 grad2 = texture2D(permTexture, Pi + vec2(ONE, ONE)).rg * 4.0 - 1.0;\n  float t2 = 0.5 - dot(Pf2, Pf2);\n  float n2;\n  if(t2 < 0.0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * dot(grad2, Pf2);\n  }\n\n  // Sum up and scale the result to cover the range [-1,1]\n  return 70.0 * (n0 + n1 + n2);\n}\n\n\n/*\n * 3D simplex noise. Comparable in speed to classic noise, better looking.\n */\nfloat snoise(vec3 P) {\n\n// The skewing and unskewing factors are much simpler for the 3D case\n#define F3 0.333333333333\n#define G3 0.166666666667\n\n  // Skew the (x,y,z) space to determine which cell of 6 simplices we're in\n \tfloat s = (P.x + P.y + P.z) * F3; // Factor for 3D skewing\n  vec3 Pi = floor(P + s);\n  float t = (Pi.x + Pi.y + Pi.z) * G3;\n  vec3 P0 = Pi - t; // Unskew the cell origin back to (x,y,z) space\n  Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n\n  vec3 Pf0 = P - P0;  // The x,y distances from the cell origin\n\n  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n  // To find out which of the six possible tetrahedra we're in, we need to\n  // determine the magnitude ordering of x, y and z components of Pf0.\n  // The method below is explained briefly in the C code. It uses a small\n  // 1D texture as a lookup table. The table is designed to work for both\n  // 3D and 4D noise, so only 8 (only 6, actually) of the 64 indices are\n  // used here.\n  float c1 = (Pf0.x > Pf0.y) ? 0.5078125 : 0.0078125; // 1/2 + 1/128\n  float c2 = (Pf0.x > Pf0.z) ? 0.25 : 0.0;\n  float c3 = (Pf0.y > Pf0.z) ? 0.125 : 0.0;\n  float sindex = c1 + c2 + c3;\n  vec3 offsets = texture2D(simplexTexture, vec2(sindex, 0.0)).rgb;\n//  vec3 offsets = texture1D(simplexTexture, sindex).rgb;\n  vec3 o1 = step(0.375, offsets);\n  vec3 o2 = step(0.125, offsets);\n\n  // Noise contribution from simplex origin\n  float perm0 = texture2D(permTexture, Pi.xy).a;\n  vec3  grad0 = texture2D(permTexture, vec2(perm0, Pi.z)).rgb * 4.0 - 1.0;\n  float t0 = 0.6 - dot(Pf0, Pf0);\n  float n0;\n  if (t0 < 0.0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * dot(grad0, Pf0);\n  }\n\n  // Noise contribution from second corner\n  vec3 Pf1 = Pf0 - o1 + G3;\n  float perm1 = texture2D(permTexture, Pi.xy + o1.xy*ONE).a;\n  vec3  grad1 = texture2D(permTexture, vec2(perm1, Pi.z + o1.z*ONE)).rgb * 4.0 - 1.0;\n  float t1 = 0.6 - dot(Pf1, Pf1);\n  float n1;\n  if (t1 < 0.0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * dot(grad1, Pf1);\n  }\n  \n  // Noise contribution from third corner\n  vec3 Pf2 = Pf0 - o2 + 2.0 * G3;\n  float perm2 = texture2D(permTexture, Pi.xy + o2.xy*ONE).a;\n  vec3  grad2 = texture2D(permTexture, vec2(perm2, Pi.z + o2.z*ONE)).rgb * 4.0 - 1.0;\n  float t2 = 0.6 - dot(Pf2, Pf2);\n  float n2;\n  if (t2 < 0.0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * dot(grad2, Pf2);\n  }\n  \n  // Noise contribution from last corner\n  vec3 Pf3 = Pf0 - vec3(1.0-3.0*G3);\n  float perm3 = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;\n  vec3  grad3 = texture2D(permTexture, vec2(perm3, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float t3 = 0.6 - dot(Pf3, Pf3);\n  float n3;\n  if(t3 < 0.0) n3 = 0.0;\n  else {\n    t3 *= t3;\n    n3 = t3 * t3 * dot(grad3, Pf3);\n  }\n\n  // Sum up and scale the result to cover the range [-1,1]\n  return 32.0 * (n0 + n1 + n2 + n3);\n}\n\n\n/*\n * 4D simplex noise. A lot faster than classic 4D noise, and better looking.\n */\n\nfloat snoise(vec4 P) {\n\n// The skewing and unskewing factors are hairy again for the 4D case\n// This is (sqrt(5.0)-1.0)/4.0\n#define F4 0.309016994375\n// This is (5.0-sqrt(5.0))/20.0\n#define G4 0.138196601125\n\n  // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n \tfloat s = (P.x + P.y + P.z + P.w) * F4; // Factor for 4D skewing\n  vec4 Pi = floor(P + s);\n  float t = (Pi.x + Pi.y + Pi.z + Pi.w) * G4;\n  vec4 P0 = Pi - t; // Unskew the cell origin back to (x,y,z,w) space\n  Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n\n  vec4 Pf0 = P - P0;  // The x,y distances from the cell origin\n\n  // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n  // To find out which of the 24 possible simplices we're in, we need to\n  // determine the magnitude ordering of x, y, z and w components of Pf0.\n  // The method below is presented without explanation. It uses a small 1D\n  // texture as a lookup table. The table is designed to work for both\n  // 3D and 4D noise and contains 64 indices, of which only 24 are actually\n  // used. An extension to 5D would require a larger texture here.\n  float c1 = (Pf0.x > Pf0.y) ? 0.5078125 : 0.0078125; // 1/2 + 1/128\n  float c2 = (Pf0.x > Pf0.z) ? 0.25 : 0.0;\n  float c3 = (Pf0.y > Pf0.z) ? 0.125 : 0.0;\n  float c4 = (Pf0.x > Pf0.w) ? 0.0625 : 0.0;\n  float c5 = (Pf0.y > Pf0.w) ? 0.03125 : 0.0;\n  float c6 = (Pf0.z > Pf0.w) ? 0.015625 : 0.0;\n  float sindex = c1 + c2 + c3 + c4 + c5 + c6;\n  vec4 offsets = texture2D(simplexTexture, vec2(sindex, 0.0)).rgba;\n//  vec4 offsets = texture1D(simplexTexture, sindex).rgba;\n  vec4 o1 = step(0.625, offsets);\n  vec4 o2 = step(0.375, offsets);\n  vec4 o3 = step(0.125, offsets);\n\n  // Noise contribution from simplex origin\n  float perm0xy = texture2D(permTexture, Pi.xy).a;\n  float perm0zw = texture2D(permTexture, Pi.zw).a;\n  vec4  grad0 = texture2D(gradTexture, vec2(perm0xy, perm0zw)).rgba * 4.0 - 1.0;\n  float t0 = 0.6 - dot(Pf0, Pf0);\n  float n0;\n  if (t0 < 0.0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * dot(grad0, Pf0);\n  }\n\n  // Noise contribution from second corner\n  vec4 Pf1 = Pf0 - o1 + G4;\n  o1 = o1 * ONE;\n  float perm1xy = texture2D(permTexture, Pi.xy + o1.xy).a;\n  float perm1zw = texture2D(permTexture, Pi.zw + o1.zw).a;\n  vec4  grad1 = texture2D(gradTexture, vec2(perm1xy, perm1zw)).rgba * 4.0 - 1.0;\n  float t1 = 0.6 - dot(Pf1, Pf1);\n  float n1;\n  if (t1 < 0.0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * dot(grad1, Pf1);\n  }\n  \n  // Noise contribution from third corner\n  vec4 Pf2 = Pf0 - o2 + 2.0 * G4;\n  o2 = o2 * ONE;\n  float perm2xy = texture2D(permTexture, Pi.xy + o2.xy).a;\n  float perm2zw = texture2D(permTexture, Pi.zw + o2.zw).a;\n  vec4  grad2 = texture2D(gradTexture, vec2(perm2xy, perm2zw)).rgba * 4.0 - 1.0;\n  float t2 = 0.6 - dot(Pf2, Pf2);\n  float n2;\n  if (t2 < 0.0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * dot(grad2, Pf2);\n  }\n  \n  // Noise contribution from fourth corner\n  vec4 Pf3 = Pf0 - o3 + 3.0 * G4;\n  o3 = o3 * ONE;\n  float perm3xy = texture2D(permTexture, Pi.xy + o3.xy).a;\n  float perm3zw = texture2D(permTexture, Pi.zw + o3.zw).a;\n  vec4  grad3 = texture2D(gradTexture, vec2(perm3xy, perm3zw)).rgba * 4.0 - 1.0;\n  float t3 = 0.6 - dot(Pf3, Pf3);\n  float n3;\n  if (t3 < 0.0) n3 = 0.0;\n  else {\n    t3 *= t3;\n    n3 = t3 * t3 * dot(grad3, Pf3);\n  }\n  \n  // Noise contribution from last corner\n  vec4 Pf4 = Pf0 - vec4(1.0-4.0*G4);\n  float perm4xy = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;\n  float perm4zw = texture2D(permTexture, Pi.zw + vec2(ONE, ONE)).a;\n  vec4  grad4 = texture2D(gradTexture, vec2(perm4xy, perm4zw)).rgba * 4.0 - 1.0;\n  float t4 = 0.6 - dot(Pf4, Pf4);\n  float n4;\n  if(t4 < 0.0) n4 = 0.0;\n  else {\n    t4 *= t4;\n    n4 = t4 * t4 * dot(grad4, Pf4);\n  }\n\n  // Sum up and scale the result to cover the range [-1,1]\n  return 27.0 * (n0 + n1 + n2 + n3 + n4);\n}\n\n          #endif\n\n\nconst float NoiseScale = 1.5;\n\nvoid main(inout vec4 ambient, inout vec4 diffuse, inout vec4 specular) {\n  float n = snoise(vPos * 16.0 * NoiseScale) * 0.75;//  n / 16.0 * 12.0;\n  float intensity = min(1.0, (n * 0.5 + 0.5));\n  ambient.rgb *= intensity;\n  diffuse.rgb *= intensity;\n}\n",
  vertex:"shared attribute vec4 VERTEX_POSITION, VERTEX_COLOR;\nshared attribute vec3 VERTEX_NORMAL;\nshared attribute vec2 VERTEX_TEXCOORDS;\n\nvoid main(void) {\n  gl_Position = pMatrix * mvMatrix * VERTEX_POSITION;\n  vPos = VERTEX_POSITION.xyz;\n//  vNormal = VERTEX_NORMAL;\n//  vColor = VERTEX_COLOR;\n//  vTexCoords = VERTEX_TEXCOORDS;\n}\n",
exports: {},
name: "granite"});
Jax.shaders['sun'] = new Jax.Shader({  common:"// Shared variables save on graphics memory and allow you to \"piggy-back\" off of\n// variables defined in other shaders:\n\nshared uniform mat3 nMatrix;\nshared uniform mat4 mvMatrix, pMatrix;\n\nshared varying vec2 vTexCoords;\nshared varying vec3 vNormal;\nshared varying vec4 vBaseColor;\nvarying vec3 vPos;\n\n// If a variable isn't shared, it will be defined specifically for this shader.\n// If this shader is used twice in one materials, unshared variables will be\n// defined twice -- once for each use of the shader.\n\n//   uniform sampler2D Texture;\n//   uniform float TextureScaleX, TextureScaleY;\n",
  fragment:"          #ifndef dependency_functions_noise\n          #define dependency_functions_noise\n      \n          /*\n * 2D, 3D and 4D Perlin noise, classic and simplex, in a GLSL fragment shader.\n *\n * Classic noise is implemented by the functions:\n * float noise(vec2 P)\n * float noise(vec3 P)\n * float noise(vec4 P)\n *\n * Simplex noise is implemented by the functions:\n * float snoise(vec2 P)\n * float snoise(vec3 P)\n * float snoise(vec4 P)\n *\n * Author: Stefan Gustavson ITN-LiTH (stegu@itn.liu.se) 2004-12-05\n * You may use, modify and redistribute this code free of charge,\n * provided that my name and this notice appears intact.\n */\n\n/*\n * NOTE: there is a formal problem with the dependent texture lookups.\n * A texture coordinate of exactly 1.0 will wrap to 0.0, so strictly speaking,\n * an error occurs every 256 units of the texture domain, and the same gradient\n * is used for two adjacent noise cells. One solution is to set the texture\n * wrap mode to \"CLAMP\" and do the wrapping explicitly in GLSL with the \"mod\"\n * operator. This could also give you noise with repetition intervals other\n * than 256 without any extra cost.\n * This error is not even noticeable to the eye even if you isolate the exact\n * position in the domain where it occurs and know exactly what to look for.\n * The noise pattern is still visually correct, so I left the bug in there.\n * \n * The value of classic 4D noise goes above 1.0 and below -1.0 at some\n * points. Not much and only very sparsely, but it happens.\n */\n\n\n/*\n * \"permTexture\" is a 256x256 texture that is used for both the permutations\n * and the 2D and 3D gradient lookup. For details, see the main C program.\n * \"simplexTexture\" is a small look-up table to determine a simplex traversal\n * order for 3D and 4D simplex noise. Details are in the C program.\n * \"gradTexture\" is a 256x256 texture with 4D gradients, similar to\n * \"permTexture\" but with the permutation index in the alpha component\n * replaced by the w component of the 4D gradient.\n * 2D classic noise uses only permTexture.\n * 2D simplex noise uses permTexture and simplexTexture.\n * 3D classic noise uses only permTexture.\n * 3D simplex noise uses permTexture and simplexTexture.\n * 4D classic noise uses permTexture and gradTexture.\n * 4D simplex noise uses all three textures.\n */\nuniform sampler2D permTexture;\n// sampler1D not supported in WebGL\n//uniform sampler1D simplexTexture;\nuniform sampler2D simplexTexture;\nuniform sampler2D gradTexture;\nuniform float time; // Used for texture animation\n\n/*\n * Both 2D and 3D texture coordinates are defined, for testing purposes.\n */\n//varying vec2 v_texCoord2D;\n//varying vec3 v_texCoord3D;\n//varying vec4 v_color;\n\n/*\n * To create offsets of one texel and one half texel in the\n * texture lookup, we need to know the texture image size.\n */\n#define ONE 0.00390625\n#define ONEHALF 0.001953125\n// The numbers above are 1/256 and 0.5/256, change accordingly\n// if you change the code to use another texture size.\n\n\n/*\n * The interpolation function. This could be a 1D texture lookup\n * to get some more speed, but it's not the main part of the algorithm.\n */\nfloat fade(float t) {\n  // return t*t*(3.0-2.0*t); // Old fade, yields discontinuous second derivative\n  return t*t*t*(t*(t*6.0-15.0)+10.0); // Improved fade, yields C2-continuous noise\n}\n\n\n/*\n * 2D classic Perlin noise. Fast, but less useful than 3D noise.\n */\nfloat noise(vec2 P)\n{\n  vec2 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled and offset for texture lookup\n  vec2 Pf = fract(P);             // Fractional part for interpolation\n\n  // Noise contribution from lower left corner\n  vec2 grad00 = texture2D(permTexture, Pi).rg * 4.0 - 1.0;\n  float n00 = dot(grad00, Pf);\n\n  // Noise contribution from lower right corner\n  vec2 grad10 = texture2D(permTexture, Pi + vec2(ONE, 0.0)).rg * 4.0 - 1.0;\n  float n10 = dot(grad10, Pf - vec2(1.0, 0.0));\n\n  // Noise contribution from upper left corner\n  vec2 grad01 = texture2D(permTexture, Pi + vec2(0.0, ONE)).rg * 4.0 - 1.0;\n  float n01 = dot(grad01, Pf - vec2(0.0, 1.0));\n\n  // Noise contribution from upper right corner\n  vec2 grad11 = texture2D(permTexture, Pi + vec2(ONE, ONE)).rg * 4.0 - 1.0;\n  float n11 = dot(grad11, Pf - vec2(1.0, 1.0));\n\n  // Blend contributions along x\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade(Pf.x));\n\n  // Blend contributions along y\n  float n_xy = mix(n_x.x, n_x.y, fade(Pf.y));\n\n  // We're done, return the final noise value.\n  return n_xy;\n}\n\n\n/*\n * 3D classic noise. Slower, but a lot more useful than 2D noise.\n */\nfloat noise(vec3 P)\n{\n  vec3 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled so +1 moves one texel\n                                  // and offset 1/2 texel to sample texel centers\n  vec3 Pf = fract(P);     // Fractional part for interpolation\n\n  // Noise contributions from (x=0, y=0), z=0 and z=1\n  float perm00 = texture2D(permTexture, Pi.xy).a ;\n  vec3  grad000 = texture2D(permTexture, vec2(perm00, Pi.z)).rgb * 4.0 - 1.0;\n  float n000 = dot(grad000, Pf);\n  vec3  grad001 = texture2D(permTexture, vec2(perm00, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n001 = dot(grad001, Pf - vec3(0.0, 0.0, 1.0));\n\n  // Noise contributions from (x=0, y=1), z=0 and z=1\n  float perm01 = texture2D(permTexture, Pi.xy + vec2(0.0, ONE)).a ;\n  vec3  grad010 = texture2D(permTexture, vec2(perm01, Pi.z)).rgb * 4.0 - 1.0;\n  float n010 = dot(grad010, Pf - vec3(0.0, 1.0, 0.0));\n  vec3  grad011 = texture2D(permTexture, vec2(perm01, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n011 = dot(grad011, Pf - vec3(0.0, 1.0, 1.0));\n\n  // Noise contributions from (x=1, y=0), z=0 and z=1\n  float perm10 = texture2D(permTexture, Pi.xy + vec2(ONE, 0.0)).a ;\n  vec3  grad100 = texture2D(permTexture, vec2(perm10, Pi.z)).rgb * 4.0 - 1.0;\n  float n100 = dot(grad100, Pf - vec3(1.0, 0.0, 0.0));\n  vec3  grad101 = texture2D(permTexture, vec2(perm10, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n101 = dot(grad101, Pf - vec3(1.0, 0.0, 1.0));\n\n  // Noise contributions from (x=1, y=1), z=0 and z=1\n  float perm11 = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a ;\n  vec3  grad110 = texture2D(permTexture, vec2(perm11, Pi.z)).rgb * 4.0 - 1.0;\n  float n110 = dot(grad110, Pf - vec3(1.0, 1.0, 0.0));\n  vec3  grad111 = texture2D(permTexture, vec2(perm11, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n111 = dot(grad111, Pf - vec3(1.0, 1.0, 1.0));\n\n  // Blend contributions along x\n  vec4 n_x = mix(vec4(n000, n001, n010, n011),\n                 vec4(n100, n101, n110, n111), fade(Pf.x));\n\n  // Blend contributions along y\n  vec2 n_xy = mix(n_x.xy, n_x.zw, fade(Pf.y));\n\n  // Blend contributions along z\n  float n_xyz = mix(n_xy.x, n_xy.y, fade(Pf.z));\n\n  // We're done, return the final noise value.\n  return n_xyz;\n}\n\n\n/*\n * 4D classic noise. Slow, but very useful. 4D simplex noise is a lot faster.\n *\n * This function performs 8 texture lookups and 16 dependent texture lookups,\n * 16 dot products, 4 mix operations and a lot of additions and multiplications.\n * Needless to say, it's not super fast. But it's not dead slow either.\n */\nfloat noise(vec4 P)\n{\n  vec4 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled so +1 moves one texel\n                                  // and offset 1/2 texel to sample texel centers\n  vec4 Pf = fract(P);      // Fractional part for interpolation\n\n  // \"n0000\" is the noise contribution from (x=0, y=0, z=0, w=0), and so on\n  float perm00xy = texture2D(permTexture, Pi.xy).a ;\n  float perm00zw = texture2D(permTexture, Pi.zw).a ;\n  vec4 grad0000 = texture2D(gradTexture, vec2(perm00xy, perm00zw)).rgba * 4.0 -1.0;\n  float n0000 = dot(grad0000, Pf);\n\n  float perm01zw = texture2D(permTexture, Pi.zw  + vec2(0.0, ONE)).a ;\n  vec4  grad0001 = texture2D(gradTexture, vec2(perm00xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n0001 = dot(grad0001, Pf - vec4(0.0, 0.0, 0.0, 1.0));\n\n  float perm10zw = texture2D(permTexture, Pi.zw  + vec2(ONE, 0.0)).a ;\n  vec4  grad0010 = texture2D(gradTexture, vec2(perm00xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n0010 = dot(grad0010, Pf - vec4(0.0, 0.0, 1.0, 0.0));\n\n  float perm11zw = texture2D(permTexture, Pi.zw  + vec2(ONE, ONE)).a ;\n  vec4  grad0011 = texture2D(gradTexture, vec2(perm00xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n0011 = dot(grad0011, Pf - vec4(0.0, 0.0, 1.0, 1.0));\n\n  float perm01xy = texture2D(permTexture, Pi.xy + vec2(0.0, ONE)).a ;\n  vec4  grad0100 = texture2D(gradTexture, vec2(perm01xy, perm00zw)).rgba * 4.0 - 1.0;\n  float n0100 = dot(grad0100, Pf - vec4(0.0, 1.0, 0.0, 0.0));\n\n  vec4  grad0101 = texture2D(gradTexture, vec2(perm01xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n0101 = dot(grad0101, Pf - vec4(0.0, 1.0, 0.0, 1.0));\n\n  vec4  grad0110 = texture2D(gradTexture, vec2(perm01xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n0110 = dot(grad0110, Pf - vec4(0.0, 1.0, 1.0, 0.0));\n\n  vec4  grad0111 = texture2D(gradTexture, vec2(perm01xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n0111 = dot(grad0111, Pf - vec4(0.0, 1.0, 1.0, 1.0));\n\n  float perm10xy = texture2D(permTexture, Pi.xy + vec2(ONE, 0.0)).a ;\n  vec4  grad1000 = texture2D(gradTexture, vec2(perm10xy, perm00zw)).rgba * 4.0 - 1.0;\n  float n1000 = dot(grad1000, Pf - vec4(1.0, 0.0, 0.0, 0.0));\n\n  vec4  grad1001 = texture2D(gradTexture, vec2(perm10xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n1001 = dot(grad1001, Pf - vec4(1.0, 0.0, 0.0, 1.0));\n\n  vec4  grad1010 = texture2D(gradTexture, vec2(perm10xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n1010 = dot(grad1010, Pf - vec4(1.0, 0.0, 1.0, 0.0));\n\n  vec4  grad1011 = texture2D(gradTexture, vec2(perm10xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n1011 = dot(grad1011, Pf - vec4(1.0, 0.0, 1.0, 1.0));\n\n  float perm11xy = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a ;\n  vec4  grad1100 = texture2D(gradTexture, vec2(perm11xy, perm00zw)).rgba * 4.0 - 1.0;\n  float n1100 = dot(grad1100, Pf - vec4(1.0, 1.0, 0.0, 0.0));\n\n  vec4  grad1101 = texture2D(gradTexture, vec2(perm11xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n1101 = dot(grad1101, Pf - vec4(1.0, 1.0, 0.0, 1.0));\n\n  vec4  grad1110 = texture2D(gradTexture, vec2(perm11xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n1110 = dot(grad1110, Pf - vec4(1.0, 1.0, 1.0, 0.0));\n\n  vec4  grad1111 = texture2D(gradTexture, vec2(perm11xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n1111 = dot(grad1111, Pf - vec4(1.0, 1.0, 1.0, 1.0));\n\n  // Blend contributions along x\n  float fadex = fade(Pf.x);\n  vec4 n_x0 = mix(vec4(n0000, n0001, n0010, n0011),\n                  vec4(n1000, n1001, n1010, n1011), fadex);\n  vec4 n_x1 = mix(vec4(n0100, n0101, n0110, n0111),\n                  vec4(n1100, n1101, n1110, n1111), fadex);\n\n  // Blend contributions along y\n  vec4 n_xy = mix(n_x0, n_x1, fade(Pf.y));\n\n  // Blend contributions along z\n  vec2 n_xyz = mix(n_xy.xy, n_xy.zw, fade(Pf.z));\n\n  // Blend contributions along w\n  float n_xyzw = mix(n_xyz.x, n_xyz.y, fade(Pf.w));\n\n  // We're done, return the final noise value.\n  return n_xyzw;\n}\n\n\n/*\n * 2D simplex noise. Somewhat slower but much better looking than classic noise.\n */\nfloat snoise(vec2 P) {\n\n// Skew and unskew factors are a bit hairy for 2D, so define them as constants\n// This is (sqrt(3.0)-1.0)/2.0\n#define F2 0.366025403784\n// This is (3.0-sqrt(3.0))/6.0\n#define G2 0.211324865405\n\n  // Skew the (x,y) space to determine which cell of 2 simplices we're in\n \tfloat s = (P.x + P.y) * F2;   // Hairy factor for 2D skewing\n  vec2 Pi = floor(P + s);\n  float t = (Pi.x + Pi.y) * G2; // Hairy factor for unskewing\n  vec2 P0 = Pi - t; // Unskew the cell origin back to (x,y) space\n  Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n\n  vec2 Pf0 = P - P0;  // The x,y distances from the cell origin\n\n  // For the 2D case, the simplex shape is an equilateral triangle.\n  // Find out whether we are above or below the x=y diagonal to\n  // determine which of the two triangles we're in.\n  vec2 o1;\n  if(Pf0.x > Pf0.y) o1 = vec2(1.0, 0.0);  // +x, +y traversal order\n  else o1 = vec2(0.0, 1.0);               // +y, +x traversal order\n\n  // Noise contribution from simplex origin\n  vec2 grad0 = texture2D(permTexture, Pi).rg * 4.0 - 1.0;\n  float t0 = 0.5 - dot(Pf0, Pf0);\n  float n0;\n  if (t0 < 0.0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * dot(grad0, Pf0);\n  }\n\n  // Noise contribution from middle corner\n  vec2 Pf1 = Pf0 - o1 + G2;\n  vec2 grad1 = texture2D(permTexture, Pi + o1*ONE).rg * 4.0 - 1.0;\n  float t1 = 0.5 - dot(Pf1, Pf1);\n  float n1;\n  if (t1 < 0.0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * dot(grad1, Pf1);\n  }\n  \n  // Noise contribution from last corner\n  vec2 Pf2 = Pf0 - vec2(1.0-2.0*G2);\n  vec2 grad2 = texture2D(permTexture, Pi + vec2(ONE, ONE)).rg * 4.0 - 1.0;\n  float t2 = 0.5 - dot(Pf2, Pf2);\n  float n2;\n  if(t2 < 0.0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * dot(grad2, Pf2);\n  }\n\n  // Sum up and scale the result to cover the range [-1,1]\n  return 70.0 * (n0 + n1 + n2);\n}\n\n\n/*\n * 3D simplex noise. Comparable in speed to classic noise, better looking.\n */\nfloat snoise(vec3 P) {\n\n// The skewing and unskewing factors are much simpler for the 3D case\n#define F3 0.333333333333\n#define G3 0.166666666667\n\n  // Skew the (x,y,z) space to determine which cell of 6 simplices we're in\n \tfloat s = (P.x + P.y + P.z) * F3; // Factor for 3D skewing\n  vec3 Pi = floor(P + s);\n  float t = (Pi.x + Pi.y + Pi.z) * G3;\n  vec3 P0 = Pi - t; // Unskew the cell origin back to (x,y,z) space\n  Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n\n  vec3 Pf0 = P - P0;  // The x,y distances from the cell origin\n\n  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n  // To find out which of the six possible tetrahedra we're in, we need to\n  // determine the magnitude ordering of x, y and z components of Pf0.\n  // The method below is explained briefly in the C code. It uses a small\n  // 1D texture as a lookup table. The table is designed to work for both\n  // 3D and 4D noise, so only 8 (only 6, actually) of the 64 indices are\n  // used here.\n  float c1 = (Pf0.x > Pf0.y) ? 0.5078125 : 0.0078125; // 1/2 + 1/128\n  float c2 = (Pf0.x > Pf0.z) ? 0.25 : 0.0;\n  float c3 = (Pf0.y > Pf0.z) ? 0.125 : 0.0;\n  float sindex = c1 + c2 + c3;\n  vec3 offsets = texture2D(simplexTexture, vec2(sindex, 0.0)).rgb;\n//  vec3 offsets = texture1D(simplexTexture, sindex).rgb;\n  vec3 o1 = step(0.375, offsets);\n  vec3 o2 = step(0.125, offsets);\n\n  // Noise contribution from simplex origin\n  float perm0 = texture2D(permTexture, Pi.xy).a;\n  vec3  grad0 = texture2D(permTexture, vec2(perm0, Pi.z)).rgb * 4.0 - 1.0;\n  float t0 = 0.6 - dot(Pf0, Pf0);\n  float n0;\n  if (t0 < 0.0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * dot(grad0, Pf0);\n  }\n\n  // Noise contribution from second corner\n  vec3 Pf1 = Pf0 - o1 + G3;\n  float perm1 = texture2D(permTexture, Pi.xy + o1.xy*ONE).a;\n  vec3  grad1 = texture2D(permTexture, vec2(perm1, Pi.z + o1.z*ONE)).rgb * 4.0 - 1.0;\n  float t1 = 0.6 - dot(Pf1, Pf1);\n  float n1;\n  if (t1 < 0.0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * dot(grad1, Pf1);\n  }\n  \n  // Noise contribution from third corner\n  vec3 Pf2 = Pf0 - o2 + 2.0 * G3;\n  float perm2 = texture2D(permTexture, Pi.xy + o2.xy*ONE).a;\n  vec3  grad2 = texture2D(permTexture, vec2(perm2, Pi.z + o2.z*ONE)).rgb * 4.0 - 1.0;\n  float t2 = 0.6 - dot(Pf2, Pf2);\n  float n2;\n  if (t2 < 0.0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * dot(grad2, Pf2);\n  }\n  \n  // Noise contribution from last corner\n  vec3 Pf3 = Pf0 - vec3(1.0-3.0*G3);\n  float perm3 = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;\n  vec3  grad3 = texture2D(permTexture, vec2(perm3, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float t3 = 0.6 - dot(Pf3, Pf3);\n  float n3;\n  if(t3 < 0.0) n3 = 0.0;\n  else {\n    t3 *= t3;\n    n3 = t3 * t3 * dot(grad3, Pf3);\n  }\n\n  // Sum up and scale the result to cover the range [-1,1]\n  return 32.0 * (n0 + n1 + n2 + n3);\n}\n\n\n/*\n * 4D simplex noise. A lot faster than classic 4D noise, and better looking.\n */\n\nfloat snoise(vec4 P) {\n\n// The skewing and unskewing factors are hairy again for the 4D case\n// This is (sqrt(5.0)-1.0)/4.0\n#define F4 0.309016994375\n// This is (5.0-sqrt(5.0))/20.0\n#define G4 0.138196601125\n\n  // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n \tfloat s = (P.x + P.y + P.z + P.w) * F4; // Factor for 4D skewing\n  vec4 Pi = floor(P + s);\n  float t = (Pi.x + Pi.y + Pi.z + Pi.w) * G4;\n  vec4 P0 = Pi - t; // Unskew the cell origin back to (x,y,z,w) space\n  Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n\n  vec4 Pf0 = P - P0;  // The x,y distances from the cell origin\n\n  // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n  // To find out which of the 24 possible simplices we're in, we need to\n  // determine the magnitude ordering of x, y, z and w components of Pf0.\n  // The method below is presented without explanation. It uses a small 1D\n  // texture as a lookup table. The table is designed to work for both\n  // 3D and 4D noise and contains 64 indices, of which only 24 are actually\n  // used. An extension to 5D would require a larger texture here.\n  float c1 = (Pf0.x > Pf0.y) ? 0.5078125 : 0.0078125; // 1/2 + 1/128\n  float c2 = (Pf0.x > Pf0.z) ? 0.25 : 0.0;\n  float c3 = (Pf0.y > Pf0.z) ? 0.125 : 0.0;\n  float c4 = (Pf0.x > Pf0.w) ? 0.0625 : 0.0;\n  float c5 = (Pf0.y > Pf0.w) ? 0.03125 : 0.0;\n  float c6 = (Pf0.z > Pf0.w) ? 0.015625 : 0.0;\n  float sindex = c1 + c2 + c3 + c4 + c5 + c6;\n  vec4 offsets = texture2D(simplexTexture, vec2(sindex, 0.0)).rgba;\n//  vec4 offsets = texture1D(simplexTexture, sindex).rgba;\n  vec4 o1 = step(0.625, offsets);\n  vec4 o2 = step(0.375, offsets);\n  vec4 o3 = step(0.125, offsets);\n\n  // Noise contribution from simplex origin\n  float perm0xy = texture2D(permTexture, Pi.xy).a;\n  float perm0zw = texture2D(permTexture, Pi.zw).a;\n  vec4  grad0 = texture2D(gradTexture, vec2(perm0xy, perm0zw)).rgba * 4.0 - 1.0;\n  float t0 = 0.6 - dot(Pf0, Pf0);\n  float n0;\n  if (t0 < 0.0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * dot(grad0, Pf0);\n  }\n\n  // Noise contribution from second corner\n  vec4 Pf1 = Pf0 - o1 + G4;\n  o1 = o1 * ONE;\n  float perm1xy = texture2D(permTexture, Pi.xy + o1.xy).a;\n  float perm1zw = texture2D(permTexture, Pi.zw + o1.zw).a;\n  vec4  grad1 = texture2D(gradTexture, vec2(perm1xy, perm1zw)).rgba * 4.0 - 1.0;\n  float t1 = 0.6 - dot(Pf1, Pf1);\n  float n1;\n  if (t1 < 0.0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * dot(grad1, Pf1);\n  }\n  \n  // Noise contribution from third corner\n  vec4 Pf2 = Pf0 - o2 + 2.0 * G4;\n  o2 = o2 * ONE;\n  float perm2xy = texture2D(permTexture, Pi.xy + o2.xy).a;\n  float perm2zw = texture2D(permTexture, Pi.zw + o2.zw).a;\n  vec4  grad2 = texture2D(gradTexture, vec2(perm2xy, perm2zw)).rgba * 4.0 - 1.0;\n  float t2 = 0.6 - dot(Pf2, Pf2);\n  float n2;\n  if (t2 < 0.0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * dot(grad2, Pf2);\n  }\n  \n  // Noise contribution from fourth corner\n  vec4 Pf3 = Pf0 - o3 + 3.0 * G4;\n  o3 = o3 * ONE;\n  float perm3xy = texture2D(permTexture, Pi.xy + o3.xy).a;\n  float perm3zw = texture2D(permTexture, Pi.zw + o3.zw).a;\n  vec4  grad3 = texture2D(gradTexture, vec2(perm3xy, perm3zw)).rgba * 4.0 - 1.0;\n  float t3 = 0.6 - dot(Pf3, Pf3);\n  float n3;\n  if (t3 < 0.0) n3 = 0.0;\n  else {\n    t3 *= t3;\n    n3 = t3 * t3 * dot(grad3, Pf3);\n  }\n  \n  // Noise contribution from last corner\n  vec4 Pf4 = Pf0 - vec4(1.0-4.0*G4);\n  float perm4xy = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;\n  float perm4zw = texture2D(permTexture, Pi.zw + vec2(ONE, ONE)).a;\n  vec4  grad4 = texture2D(gradTexture, vec2(perm4xy, perm4zw)).rgba * 4.0 - 1.0;\n  float t4 = 0.6 - dot(Pf4, Pf4);\n  float n4;\n  if(t4 < 0.0) n4 = 0.0;\n  else {\n    t4 *= t4;\n    n4 = t4 * t4 * dot(grad4, Pf4);\n  }\n\n  // Sum up and scale the result to cover the range [-1,1]\n  return 27.0 * (n0 + n1 + n2 + n3 + n4);\n}\n\n          #endif\n\n\nuniform float TIME;\n\nvoid main(inout vec4 ambient, inout vec4 diffuse, inout vec4 specular) {\n  float n = abs(snoise(vec4(vPos*1.0, TIME*0.25)) - 0.5) + \n            abs(snoise(vec4(vPos*2.0, TIME*0.25)) - 0.25) + \n            abs(snoise(vec4(vPos*4.0, TIME*0.25)) - 0.125) + \n            abs(snoise(vec4(vPos*8.0, TIME*0.25)) - 0.0625) + \n            abs(snoise(vec4(vPos*16.0, TIME*0.25)) - 0.03125);\n            \n  diffuse *= n;\n  ambient *= n;\n}\n",
  vertex:"shared attribute vec4 VERTEX_POSITION, VERTEX_COLOR;\nshared attribute vec3 VERTEX_NORMAL;\nshared attribute vec2 VERTEX_TEXCOORDS;\n\nvoid main(void) {\n  gl_Position = pMatrix * mvMatrix * VERTEX_POSITION;\n  vPos = VERTEX_POSITION.xyz;\n//  vNormal = VERTEX_NORMAL;\n//  vColor = VERTEX_COLOR;\n//  vTexCoords = VERTEX_TEXCOORDS;\n}\n",
exports: {},
name: "sun"});
Jax.shaders['wood'] = new Jax.Shader({  common:"// Shared variables save on graphics memory and allow you to \"piggy-back\" off of\n// variables defined in other shaders:\n\nshared uniform mat3 nMatrix;\nshared uniform mat4 mvMatrix, pMatrix;\n\nshared varying vec2 vTexCoords;\nshared varying vec3 vNormal;\nshared varying vec4 vBaseColor;\n\nvarying vec3 vPos;\n\n// If a variable isn't shared, it will be defined specifically for this shader.\n// If this shader is used twice in one materials, unshared variables will be\n// defined twice -- once for each use of the shader.\n\n//   uniform sampler2D Texture;\n//   uniform float TextureScaleX, TextureScaleY;\n",
  fragment:"          #ifndef dependency_functions_noise\n          #define dependency_functions_noise\n      \n          /*\n * 2D, 3D and 4D Perlin noise, classic and simplex, in a GLSL fragment shader.\n *\n * Classic noise is implemented by the functions:\n * float noise(vec2 P)\n * float noise(vec3 P)\n * float noise(vec4 P)\n *\n * Simplex noise is implemented by the functions:\n * float snoise(vec2 P)\n * float snoise(vec3 P)\n * float snoise(vec4 P)\n *\n * Author: Stefan Gustavson ITN-LiTH (stegu@itn.liu.se) 2004-12-05\n * You may use, modify and redistribute this code free of charge,\n * provided that my name and this notice appears intact.\n */\n\n/*\n * NOTE: there is a formal problem with the dependent texture lookups.\n * A texture coordinate of exactly 1.0 will wrap to 0.0, so strictly speaking,\n * an error occurs every 256 units of the texture domain, and the same gradient\n * is used for two adjacent noise cells. One solution is to set the texture\n * wrap mode to \"CLAMP\" and do the wrapping explicitly in GLSL with the \"mod\"\n * operator. This could also give you noise with repetition intervals other\n * than 256 without any extra cost.\n * This error is not even noticeable to the eye even if you isolate the exact\n * position in the domain where it occurs and know exactly what to look for.\n * The noise pattern is still visually correct, so I left the bug in there.\n * \n * The value of classic 4D noise goes above 1.0 and below -1.0 at some\n * points. Not much and only very sparsely, but it happens.\n */\n\n\n/*\n * \"permTexture\" is a 256x256 texture that is used for both the permutations\n * and the 2D and 3D gradient lookup. For details, see the main C program.\n * \"simplexTexture\" is a small look-up table to determine a simplex traversal\n * order for 3D and 4D simplex noise. Details are in the C program.\n * \"gradTexture\" is a 256x256 texture with 4D gradients, similar to\n * \"permTexture\" but with the permutation index in the alpha component\n * replaced by the w component of the 4D gradient.\n * 2D classic noise uses only permTexture.\n * 2D simplex noise uses permTexture and simplexTexture.\n * 3D classic noise uses only permTexture.\n * 3D simplex noise uses permTexture and simplexTexture.\n * 4D classic noise uses permTexture and gradTexture.\n * 4D simplex noise uses all three textures.\n */\nuniform sampler2D permTexture;\n// sampler1D not supported in WebGL\n//uniform sampler1D simplexTexture;\nuniform sampler2D simplexTexture;\nuniform sampler2D gradTexture;\nuniform float time; // Used for texture animation\n\n/*\n * Both 2D and 3D texture coordinates are defined, for testing purposes.\n */\n//varying vec2 v_texCoord2D;\n//varying vec3 v_texCoord3D;\n//varying vec4 v_color;\n\n/*\n * To create offsets of one texel and one half texel in the\n * texture lookup, we need to know the texture image size.\n */\n#define ONE 0.00390625\n#define ONEHALF 0.001953125\n// The numbers above are 1/256 and 0.5/256, change accordingly\n// if you change the code to use another texture size.\n\n\n/*\n * The interpolation function. This could be a 1D texture lookup\n * to get some more speed, but it's not the main part of the algorithm.\n */\nfloat fade(float t) {\n  // return t*t*(3.0-2.0*t); // Old fade, yields discontinuous second derivative\n  return t*t*t*(t*(t*6.0-15.0)+10.0); // Improved fade, yields C2-continuous noise\n}\n\n\n/*\n * 2D classic Perlin noise. Fast, but less useful than 3D noise.\n */\nfloat noise(vec2 P)\n{\n  vec2 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled and offset for texture lookup\n  vec2 Pf = fract(P);             // Fractional part for interpolation\n\n  // Noise contribution from lower left corner\n  vec2 grad00 = texture2D(permTexture, Pi).rg * 4.0 - 1.0;\n  float n00 = dot(grad00, Pf);\n\n  // Noise contribution from lower right corner\n  vec2 grad10 = texture2D(permTexture, Pi + vec2(ONE, 0.0)).rg * 4.0 - 1.0;\n  float n10 = dot(grad10, Pf - vec2(1.0, 0.0));\n\n  // Noise contribution from upper left corner\n  vec2 grad01 = texture2D(permTexture, Pi + vec2(0.0, ONE)).rg * 4.0 - 1.0;\n  float n01 = dot(grad01, Pf - vec2(0.0, 1.0));\n\n  // Noise contribution from upper right corner\n  vec2 grad11 = texture2D(permTexture, Pi + vec2(ONE, ONE)).rg * 4.0 - 1.0;\n  float n11 = dot(grad11, Pf - vec2(1.0, 1.0));\n\n  // Blend contributions along x\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade(Pf.x));\n\n  // Blend contributions along y\n  float n_xy = mix(n_x.x, n_x.y, fade(Pf.y));\n\n  // We're done, return the final noise value.\n  return n_xy;\n}\n\n\n/*\n * 3D classic noise. Slower, but a lot more useful than 2D noise.\n */\nfloat noise(vec3 P)\n{\n  vec3 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled so +1 moves one texel\n                                  // and offset 1/2 texel to sample texel centers\n  vec3 Pf = fract(P);     // Fractional part for interpolation\n\n  // Noise contributions from (x=0, y=0), z=0 and z=1\n  float perm00 = texture2D(permTexture, Pi.xy).a ;\n  vec3  grad000 = texture2D(permTexture, vec2(perm00, Pi.z)).rgb * 4.0 - 1.0;\n  float n000 = dot(grad000, Pf);\n  vec3  grad001 = texture2D(permTexture, vec2(perm00, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n001 = dot(grad001, Pf - vec3(0.0, 0.0, 1.0));\n\n  // Noise contributions from (x=0, y=1), z=0 and z=1\n  float perm01 = texture2D(permTexture, Pi.xy + vec2(0.0, ONE)).a ;\n  vec3  grad010 = texture2D(permTexture, vec2(perm01, Pi.z)).rgb * 4.0 - 1.0;\n  float n010 = dot(grad010, Pf - vec3(0.0, 1.0, 0.0));\n  vec3  grad011 = texture2D(permTexture, vec2(perm01, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n011 = dot(grad011, Pf - vec3(0.0, 1.0, 1.0));\n\n  // Noise contributions from (x=1, y=0), z=0 and z=1\n  float perm10 = texture2D(permTexture, Pi.xy + vec2(ONE, 0.0)).a ;\n  vec3  grad100 = texture2D(permTexture, vec2(perm10, Pi.z)).rgb * 4.0 - 1.0;\n  float n100 = dot(grad100, Pf - vec3(1.0, 0.0, 0.0));\n  vec3  grad101 = texture2D(permTexture, vec2(perm10, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n101 = dot(grad101, Pf - vec3(1.0, 0.0, 1.0));\n\n  // Noise contributions from (x=1, y=1), z=0 and z=1\n  float perm11 = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a ;\n  vec3  grad110 = texture2D(permTexture, vec2(perm11, Pi.z)).rgb * 4.0 - 1.0;\n  float n110 = dot(grad110, Pf - vec3(1.0, 1.0, 0.0));\n  vec3  grad111 = texture2D(permTexture, vec2(perm11, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n111 = dot(grad111, Pf - vec3(1.0, 1.0, 1.0));\n\n  // Blend contributions along x\n  vec4 n_x = mix(vec4(n000, n001, n010, n011),\n                 vec4(n100, n101, n110, n111), fade(Pf.x));\n\n  // Blend contributions along y\n  vec2 n_xy = mix(n_x.xy, n_x.zw, fade(Pf.y));\n\n  // Blend contributions along z\n  float n_xyz = mix(n_xy.x, n_xy.y, fade(Pf.z));\n\n  // We're done, return the final noise value.\n  return n_xyz;\n}\n\n\n/*\n * 4D classic noise. Slow, but very useful. 4D simplex noise is a lot faster.\n *\n * This function performs 8 texture lookups and 16 dependent texture lookups,\n * 16 dot products, 4 mix operations and a lot of additions and multiplications.\n * Needless to say, it's not super fast. But it's not dead slow either.\n */\nfloat noise(vec4 P)\n{\n  vec4 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled so +1 moves one texel\n                                  // and offset 1/2 texel to sample texel centers\n  vec4 Pf = fract(P);      // Fractional part for interpolation\n\n  // \"n0000\" is the noise contribution from (x=0, y=0, z=0, w=0), and so on\n  float perm00xy = texture2D(permTexture, Pi.xy).a ;\n  float perm00zw = texture2D(permTexture, Pi.zw).a ;\n  vec4 grad0000 = texture2D(gradTexture, vec2(perm00xy, perm00zw)).rgba * 4.0 -1.0;\n  float n0000 = dot(grad0000, Pf);\n\n  float perm01zw = texture2D(permTexture, Pi.zw  + vec2(0.0, ONE)).a ;\n  vec4  grad0001 = texture2D(gradTexture, vec2(perm00xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n0001 = dot(grad0001, Pf - vec4(0.0, 0.0, 0.0, 1.0));\n\n  float perm10zw = texture2D(permTexture, Pi.zw  + vec2(ONE, 0.0)).a ;\n  vec4  grad0010 = texture2D(gradTexture, vec2(perm00xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n0010 = dot(grad0010, Pf - vec4(0.0, 0.0, 1.0, 0.0));\n\n  float perm11zw = texture2D(permTexture, Pi.zw  + vec2(ONE, ONE)).a ;\n  vec4  grad0011 = texture2D(gradTexture, vec2(perm00xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n0011 = dot(grad0011, Pf - vec4(0.0, 0.0, 1.0, 1.0));\n\n  float perm01xy = texture2D(permTexture, Pi.xy + vec2(0.0, ONE)).a ;\n  vec4  grad0100 = texture2D(gradTexture, vec2(perm01xy, perm00zw)).rgba * 4.0 - 1.0;\n  float n0100 = dot(grad0100, Pf - vec4(0.0, 1.0, 0.0, 0.0));\n\n  vec4  grad0101 = texture2D(gradTexture, vec2(perm01xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n0101 = dot(grad0101, Pf - vec4(0.0, 1.0, 0.0, 1.0));\n\n  vec4  grad0110 = texture2D(gradTexture, vec2(perm01xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n0110 = dot(grad0110, Pf - vec4(0.0, 1.0, 1.0, 0.0));\n\n  vec4  grad0111 = texture2D(gradTexture, vec2(perm01xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n0111 = dot(grad0111, Pf - vec4(0.0, 1.0, 1.0, 1.0));\n\n  float perm10xy = texture2D(permTexture, Pi.xy + vec2(ONE, 0.0)).a ;\n  vec4  grad1000 = texture2D(gradTexture, vec2(perm10xy, perm00zw)).rgba * 4.0 - 1.0;\n  float n1000 = dot(grad1000, Pf - vec4(1.0, 0.0, 0.0, 0.0));\n\n  vec4  grad1001 = texture2D(gradTexture, vec2(perm10xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n1001 = dot(grad1001, Pf - vec4(1.0, 0.0, 0.0, 1.0));\n\n  vec4  grad1010 = texture2D(gradTexture, vec2(perm10xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n1010 = dot(grad1010, Pf - vec4(1.0, 0.0, 1.0, 0.0));\n\n  vec4  grad1011 = texture2D(gradTexture, vec2(perm10xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n1011 = dot(grad1011, Pf - vec4(1.0, 0.0, 1.0, 1.0));\n\n  float perm11xy = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a ;\n  vec4  grad1100 = texture2D(gradTexture, vec2(perm11xy, perm00zw)).rgba * 4.0 - 1.0;\n  float n1100 = dot(grad1100, Pf - vec4(1.0, 1.0, 0.0, 0.0));\n\n  vec4  grad1101 = texture2D(gradTexture, vec2(perm11xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n1101 = dot(grad1101, Pf - vec4(1.0, 1.0, 0.0, 1.0));\n\n  vec4  grad1110 = texture2D(gradTexture, vec2(perm11xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n1110 = dot(grad1110, Pf - vec4(1.0, 1.0, 1.0, 0.0));\n\n  vec4  grad1111 = texture2D(gradTexture, vec2(perm11xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n1111 = dot(grad1111, Pf - vec4(1.0, 1.0, 1.0, 1.0));\n\n  // Blend contributions along x\n  float fadex = fade(Pf.x);\n  vec4 n_x0 = mix(vec4(n0000, n0001, n0010, n0011),\n                  vec4(n1000, n1001, n1010, n1011), fadex);\n  vec4 n_x1 = mix(vec4(n0100, n0101, n0110, n0111),\n                  vec4(n1100, n1101, n1110, n1111), fadex);\n\n  // Blend contributions along y\n  vec4 n_xy = mix(n_x0, n_x1, fade(Pf.y));\n\n  // Blend contributions along z\n  vec2 n_xyz = mix(n_xy.xy, n_xy.zw, fade(Pf.z));\n\n  // Blend contributions along w\n  float n_xyzw = mix(n_xyz.x, n_xyz.y, fade(Pf.w));\n\n  // We're done, return the final noise value.\n  return n_xyzw;\n}\n\n\n/*\n * 2D simplex noise. Somewhat slower but much better looking than classic noise.\n */\nfloat snoise(vec2 P) {\n\n// Skew and unskew factors are a bit hairy for 2D, so define them as constants\n// This is (sqrt(3.0)-1.0)/2.0\n#define F2 0.366025403784\n// This is (3.0-sqrt(3.0))/6.0\n#define G2 0.211324865405\n\n  // Skew the (x,y) space to determine which cell of 2 simplices we're in\n \tfloat s = (P.x + P.y) * F2;   // Hairy factor for 2D skewing\n  vec2 Pi = floor(P + s);\n  float t = (Pi.x + Pi.y) * G2; // Hairy factor for unskewing\n  vec2 P0 = Pi - t; // Unskew the cell origin back to (x,y) space\n  Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n\n  vec2 Pf0 = P - P0;  // The x,y distances from the cell origin\n\n  // For the 2D case, the simplex shape is an equilateral triangle.\n  // Find out whether we are above or below the x=y diagonal to\n  // determine which of the two triangles we're in.\n  vec2 o1;\n  if(Pf0.x > Pf0.y) o1 = vec2(1.0, 0.0);  // +x, +y traversal order\n  else o1 = vec2(0.0, 1.0);               // +y, +x traversal order\n\n  // Noise contribution from simplex origin\n  vec2 grad0 = texture2D(permTexture, Pi).rg * 4.0 - 1.0;\n  float t0 = 0.5 - dot(Pf0, Pf0);\n  float n0;\n  if (t0 < 0.0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * dot(grad0, Pf0);\n  }\n\n  // Noise contribution from middle corner\n  vec2 Pf1 = Pf0 - o1 + G2;\n  vec2 grad1 = texture2D(permTexture, Pi + o1*ONE).rg * 4.0 - 1.0;\n  float t1 = 0.5 - dot(Pf1, Pf1);\n  float n1;\n  if (t1 < 0.0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * dot(grad1, Pf1);\n  }\n  \n  // Noise contribution from last corner\n  vec2 Pf2 = Pf0 - vec2(1.0-2.0*G2);\n  vec2 grad2 = texture2D(permTexture, Pi + vec2(ONE, ONE)).rg * 4.0 - 1.0;\n  float t2 = 0.5 - dot(Pf2, Pf2);\n  float n2;\n  if(t2 < 0.0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * dot(grad2, Pf2);\n  }\n\n  // Sum up and scale the result to cover the range [-1,1]\n  return 70.0 * (n0 + n1 + n2);\n}\n\n\n/*\n * 3D simplex noise. Comparable in speed to classic noise, better looking.\n */\nfloat snoise(vec3 P) {\n\n// The skewing and unskewing factors are much simpler for the 3D case\n#define F3 0.333333333333\n#define G3 0.166666666667\n\n  // Skew the (x,y,z) space to determine which cell of 6 simplices we're in\n \tfloat s = (P.x + P.y + P.z) * F3; // Factor for 3D skewing\n  vec3 Pi = floor(P + s);\n  float t = (Pi.x + Pi.y + Pi.z) * G3;\n  vec3 P0 = Pi - t; // Unskew the cell origin back to (x,y,z) space\n  Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n\n  vec3 Pf0 = P - P0;  // The x,y distances from the cell origin\n\n  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n  // To find out which of the six possible tetrahedra we're in, we need to\n  // determine the magnitude ordering of x, y and z components of Pf0.\n  // The method below is explained briefly in the C code. It uses a small\n  // 1D texture as a lookup table. The table is designed to work for both\n  // 3D and 4D noise, so only 8 (only 6, actually) of the 64 indices are\n  // used here.\n  float c1 = (Pf0.x > Pf0.y) ? 0.5078125 : 0.0078125; // 1/2 + 1/128\n  float c2 = (Pf0.x > Pf0.z) ? 0.25 : 0.0;\n  float c3 = (Pf0.y > Pf0.z) ? 0.125 : 0.0;\n  float sindex = c1 + c2 + c3;\n  vec3 offsets = texture2D(simplexTexture, vec2(sindex, 0.0)).rgb;\n//  vec3 offsets = texture1D(simplexTexture, sindex).rgb;\n  vec3 o1 = step(0.375, offsets);\n  vec3 o2 = step(0.125, offsets);\n\n  // Noise contribution from simplex origin\n  float perm0 = texture2D(permTexture, Pi.xy).a;\n  vec3  grad0 = texture2D(permTexture, vec2(perm0, Pi.z)).rgb * 4.0 - 1.0;\n  float t0 = 0.6 - dot(Pf0, Pf0);\n  float n0;\n  if (t0 < 0.0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * dot(grad0, Pf0);\n  }\n\n  // Noise contribution from second corner\n  vec3 Pf1 = Pf0 - o1 + G3;\n  float perm1 = texture2D(permTexture, Pi.xy + o1.xy*ONE).a;\n  vec3  grad1 = texture2D(permTexture, vec2(perm1, Pi.z + o1.z*ONE)).rgb * 4.0 - 1.0;\n  float t1 = 0.6 - dot(Pf1, Pf1);\n  float n1;\n  if (t1 < 0.0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * dot(grad1, Pf1);\n  }\n  \n  // Noise contribution from third corner\n  vec3 Pf2 = Pf0 - o2 + 2.0 * G3;\n  float perm2 = texture2D(permTexture, Pi.xy + o2.xy*ONE).a;\n  vec3  grad2 = texture2D(permTexture, vec2(perm2, Pi.z + o2.z*ONE)).rgb * 4.0 - 1.0;\n  float t2 = 0.6 - dot(Pf2, Pf2);\n  float n2;\n  if (t2 < 0.0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * dot(grad2, Pf2);\n  }\n  \n  // Noise contribution from last corner\n  vec3 Pf3 = Pf0 - vec3(1.0-3.0*G3);\n  float perm3 = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;\n  vec3  grad3 = texture2D(permTexture, vec2(perm3, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float t3 = 0.6 - dot(Pf3, Pf3);\n  float n3;\n  if(t3 < 0.0) n3 = 0.0;\n  else {\n    t3 *= t3;\n    n3 = t3 * t3 * dot(grad3, Pf3);\n  }\n\n  // Sum up and scale the result to cover the range [-1,1]\n  return 32.0 * (n0 + n1 + n2 + n3);\n}\n\n\n/*\n * 4D simplex noise. A lot faster than classic 4D noise, and better looking.\n */\n\nfloat snoise(vec4 P) {\n\n// The skewing and unskewing factors are hairy again for the 4D case\n// This is (sqrt(5.0)-1.0)/4.0\n#define F4 0.309016994375\n// This is (5.0-sqrt(5.0))/20.0\n#define G4 0.138196601125\n\n  // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n \tfloat s = (P.x + P.y + P.z + P.w) * F4; // Factor for 4D skewing\n  vec4 Pi = floor(P + s);\n  float t = (Pi.x + Pi.y + Pi.z + Pi.w) * G4;\n  vec4 P0 = Pi - t; // Unskew the cell origin back to (x,y,z,w) space\n  Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup\n\n  vec4 Pf0 = P - P0;  // The x,y distances from the cell origin\n\n  // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n  // To find out which of the 24 possible simplices we're in, we need to\n  // determine the magnitude ordering of x, y, z and w components of Pf0.\n  // The method below is presented without explanation. It uses a small 1D\n  // texture as a lookup table. The table is designed to work for both\n  // 3D and 4D noise and contains 64 indices, of which only 24 are actually\n  // used. An extension to 5D would require a larger texture here.\n  float c1 = (Pf0.x > Pf0.y) ? 0.5078125 : 0.0078125; // 1/2 + 1/128\n  float c2 = (Pf0.x > Pf0.z) ? 0.25 : 0.0;\n  float c3 = (Pf0.y > Pf0.z) ? 0.125 : 0.0;\n  float c4 = (Pf0.x > Pf0.w) ? 0.0625 : 0.0;\n  float c5 = (Pf0.y > Pf0.w) ? 0.03125 : 0.0;\n  float c6 = (Pf0.z > Pf0.w) ? 0.015625 : 0.0;\n  float sindex = c1 + c2 + c3 + c4 + c5 + c6;\n  vec4 offsets = texture2D(simplexTexture, vec2(sindex, 0.0)).rgba;\n//  vec4 offsets = texture1D(simplexTexture, sindex).rgba;\n  vec4 o1 = step(0.625, offsets);\n  vec4 o2 = step(0.375, offsets);\n  vec4 o3 = step(0.125, offsets);\n\n  // Noise contribution from simplex origin\n  float perm0xy = texture2D(permTexture, Pi.xy).a;\n  float perm0zw = texture2D(permTexture, Pi.zw).a;\n  vec4  grad0 = texture2D(gradTexture, vec2(perm0xy, perm0zw)).rgba * 4.0 - 1.0;\n  float t0 = 0.6 - dot(Pf0, Pf0);\n  float n0;\n  if (t0 < 0.0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * dot(grad0, Pf0);\n  }\n\n  // Noise contribution from second corner\n  vec4 Pf1 = Pf0 - o1 + G4;\n  o1 = o1 * ONE;\n  float perm1xy = texture2D(permTexture, Pi.xy + o1.xy).a;\n  float perm1zw = texture2D(permTexture, Pi.zw + o1.zw).a;\n  vec4  grad1 = texture2D(gradTexture, vec2(perm1xy, perm1zw)).rgba * 4.0 - 1.0;\n  float t1 = 0.6 - dot(Pf1, Pf1);\n  float n1;\n  if (t1 < 0.0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * dot(grad1, Pf1);\n  }\n  \n  // Noise contribution from third corner\n  vec4 Pf2 = Pf0 - o2 + 2.0 * G4;\n  o2 = o2 * ONE;\n  float perm2xy = texture2D(permTexture, Pi.xy + o2.xy).a;\n  float perm2zw = texture2D(permTexture, Pi.zw + o2.zw).a;\n  vec4  grad2 = texture2D(gradTexture, vec2(perm2xy, perm2zw)).rgba * 4.0 - 1.0;\n  float t2 = 0.6 - dot(Pf2, Pf2);\n  float n2;\n  if (t2 < 0.0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * dot(grad2, Pf2);\n  }\n  \n  // Noise contribution from fourth corner\n  vec4 Pf3 = Pf0 - o3 + 3.0 * G4;\n  o3 = o3 * ONE;\n  float perm3xy = texture2D(permTexture, Pi.xy + o3.xy).a;\n  float perm3zw = texture2D(permTexture, Pi.zw + o3.zw).a;\n  vec4  grad3 = texture2D(gradTexture, vec2(perm3xy, perm3zw)).rgba * 4.0 - 1.0;\n  float t3 = 0.6 - dot(Pf3, Pf3);\n  float n3;\n  if (t3 < 0.0) n3 = 0.0;\n  else {\n    t3 *= t3;\n    n3 = t3 * t3 * dot(grad3, Pf3);\n  }\n  \n  // Noise contribution from last corner\n  vec4 Pf4 = Pf0 - vec4(1.0-4.0*G4);\n  float perm4xy = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;\n  float perm4zw = texture2D(permTexture, Pi.zw + vec2(ONE, ONE)).a;\n  vec4  grad4 = texture2D(gradTexture, vec2(perm4xy, perm4zw)).rgba * 4.0 - 1.0;\n  float t4 = 0.6 - dot(Pf4, Pf4);\n  float n4;\n  if(t4 < 0.0) n4 = 0.0;\n  else {\n    t4 *= t4;\n    n4 = t4 * t4 * dot(grad4, Pf4);\n  }\n\n  // Sum up and scale the result to cover the range [-1,1]\n  return 27.0 * (n0 + n1 + n2 + n3 + n4);\n}\n\n          #endif\n\n\n/* if I weren't lazy, these would be uniforms. */\nconst vec3 LightWood = vec3(0.6, 0.3, 0.1);\nconst vec3 DarkWood = vec3(0.4, 0.2, 0.07);\nconst float RingFreq = 4.0;\nconst float LightGrains = 1.0;\nconst float DarkGrains = 0.0;\nconst float GrainThreshold = 0.5;\nconst vec3 NoiseScale = vec3(0.5, 0.1, 0.1);\nconst float Noisiness = 3.0;\nconst float GrainScale = 27.0;\n\nvoid main(inout vec4 ambient, inout vec4 diffuse, inout vec4 specular) {\n  float n = snoise(vPos * NoiseScale) * Noisiness;\n  vec3 noisevec = vec3(snoise(vPos * NoiseScale) * Noisiness,\n                       snoise(vPos*2.0 * NoiseScale) / 2.0 * Noisiness,\n                       snoise(vPos*4.0 * NoiseScale) / 4.0 * Noisiness);\n                       \n  vec3 location = vPos + noisevec;\n  float dist = sqrt(location.x * location.x + location.y * location.y + location.z * location.z);\n  dist *= RingFreq;\n  \n  float r = fract(dist + noisevec.x + noisevec.y + noisevec.z) * 2.0;\n  if (r > 1.0) r = 2.0 - r;\n  \n  vec3 color = mix(LightWood, DarkWood, r);\n  r = fract((vPos.x + vPos.z) * GrainScale + 0.5);\n  noisevec.z *= r;\n  if (r < GrainThreshold)\n    color += LightWood * LightGrains * noisevec.z;\n  else\n    color -= LightWood * DarkGrains * noisevec.z;\n    \n  ambient.rgb *= color;\n  diffuse.rgb *= color;\n}\n",
  vertex:"shared attribute vec4 VERTEX_POSITION, VERTEX_COLOR;\nshared attribute vec3 VERTEX_NORMAL;\nshared attribute vec2 VERTEX_TEXCOORDS;\n\nvoid main(void) {\n  gl_Position = pMatrix * mvMatrix * VERTEX_POSITION;\n  vPos = VERTEX_POSITION.xyz;\n  \n//  vNormal = VERTEX_NORMAL;\n//  vColor = VERTEX_COLOR;\n//  vTexCoords = VERTEX_TEXCOORDS;\n}\n",
exports: {},
name: "wood"});
LightSource.addResources({"light":{"shadowcaster":true,"enabled":true,"position":{"x":2.0,"y":2.0,"z":0},"type":"POINT_LIGHT","attenuation":{"constant":0,"linear":0.15,"quadratic":0},"color":{"ambient":{"red":0.2,"green":0.2,"blue":0.2,"alpha":1},"diffuse":{"red":0.5,"green":0.5,"blue":0.5,"alpha":1.0},"specular":{"red":0.2,"green":0.2,"blue":0.2,"alpha":1.0}}}});
Material.addResources({"electrical":{"ambient":{"red":0.02,"green":0.02,"blue":0.04,"alpha":1.0},"diffuse":{"red":0.3,"green":0.3,"blue":0.4,"alpha":1.0},"specular":{"red":1.0,"green":1.0,"blue":1.0,"alpha":1.0},"shininess":30,"layers":[{"type":"Lighting"},{"type":"Electrical"}]},"granite":{"ambient":{"red":1.0,"green":1.0,"blue":1.0,"alpha":1.0},"diffuse":{"red":1.0,"green":1.0,"blue":1.0,"alpha":1.0},"specular":{"red":1.0,"green":1.0,"blue":1.0,"alpha":1.0},"shininess":120,"layers":[{"type":"Lighting"},{"type":"Granite"}]},"sun":{"ambient":{"red":1.0,"green":0.35,"blue":0.25,"alpha":1.0},"diffuse":{"red":1.0,"green":0.35,"blue":0.25,"alpha":1.0},"specular":{"red":1.0,"green":1.0,"blue":1.0,"alpha":1.0},"shininess":30,"layers":[{"type":"Lighting"},{"type":"Sun"}]},"wood":{"ambient":{"red":1,"green":1,"blue":1,"alpha":1.0},"diffuse":{"red":1,"green":1,"blue":1,"alpha":1.0},"specular":{"red":1.0,"green":1.0,"blue":1.0,"alpha":1.0},"shininess":30,"layers":[{"type":"Lighting"},{"type":"Wood"}]}});
Jax.routes.root(MainController, "index");
Jax.routes.map("main/index", MainController, "index");
if (Jax.doVersionCheck) Jax.doVersionCheck('0.0.0.7');
else alert('Your Jax gem version is newer than your Jax JavaScript library!\n\nRun `rake jax:update` to fix this.');
